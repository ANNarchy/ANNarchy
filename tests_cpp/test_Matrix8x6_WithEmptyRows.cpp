/*
 *    test_Matrix8x6_WithEmptyRows.cpp
 *
 *    This file is part of ANNarchy.
 *
 *    Copyright (C) 2025  Helge Uelo Dinkelbach <helge.dinkelbach@gmail.com>
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    ANNarchy is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include "test_MatrixCommon.hpp"

template<typename Config>
class Matrix8x6_WithEmptyRows: public ::testing::Test {
protected:
    using MatrixType = typename Config::MatrixClassType;
    using StorageType = typename Config::MatrixValueType;

    MatrixType* mat_;

    std::vector<int> post_ranks_;
    std::vector<std::vector<int>> pre_ranks_;
    std::vector<std::vector<double>> values_;

    void SetUp() override {

        /* 
            We will use this matrix pattern as text example

                0, 0, 0, 0, 0, 0,
                1, 0, 0, 0, 0, 0,
                0, 0, 2, 0, 0, 0,
                0, 3, 4, 0, 0, 0,
                0, 0, 5, 6, 7, 0,
                0, 0, 0, 0, 0, 0,
                0, 0, 8, 0, 0, 0,
                0, 0, 0, 0, 9,10

         */

        // In ANNarchy matrices are initialized in most case from a LIL
        // structure, we need to construct this here from hand.

        post_ranks_.push_back(1);       // 2nd row (dense) -> 1st row (sparse)
        pre_ranks_.push_back({0});
        values_.push_back({1.0});

        post_ranks_.push_back(2);       // 3rd row (dense) -> 2nd row (sparse)
        pre_ranks_.push_back({2});
        values_.push_back({2.0});
        
        post_ranks_.push_back(3);       // 4th row (dense) -> 3rd row (sparse)
        pre_ranks_.push_back({1,2});
        values_.push_back({3.0,4.0});

        post_ranks_.push_back(4);       // 5th row (dense) -> 4th row (sparse)
        pre_ranks_.push_back({2,3,4});
        values_.push_back({5.0,6.0,7.0});

        post_ranks_.push_back(6);       // 7th row (dense) -> 5th row (sparse)
        pre_ranks_.push_back({2});
        values_.push_back({8.0});

        post_ranks_.push_back(7);       // 8th row (dense) -> 6th row (sparse)
        pre_ranks_.push_back({4,5});
        values_.push_back({9.,10.});

        //
        // Initialize the Matrix container
        if constexpr(std::is_same_v<MatrixType, BSRMatrix<int, int, char, true>> ||
                     std::is_same_v<MatrixType, BSRMatrixBitmask<int, int, char, true>>) {
            // BSR needs a additional block size
            mat_ = new MatrixType(8, 6, 2);
        } else if constexpr(std::is_same_v<MatrixType, SELLMatrix<int, int, true>>) {
            // SELL needs slice size S, here I choose 3 this means two blocks will be created.
            mat_ = new MatrixType(8, 6, 3);            
        } else {
            // for most formats: num_rows, num_columns
            mat_ = new MatrixType(8, 6);
        }

        mat_->init_matrix_from_lil(post_ranks_, pre_ranks_);
    }

    void TearDown() override {
        delete mat_;
    }

    /**
     * @details     The matrix values are stored in a compressed fashion. However, the data container depends on the used format.
     *              This function creates a pre-initialized variable which should be compared with the LIL representation
     *              generated by Matrix8x6_WithEmptyRows::generate_expected_LIL().
     */
    StorageType generate_inited_matrix_variable() {
        StorageType inited;
        
        if constexpr(std::is_same_v<MatrixType, BSRMatrix<int, int, char, true>> ||
                     std::is_same_v<MatrixType, BSRMatrixBitmask<int, int, char, true>>) {
            // BSR formats

        } else if constexpr(std::is_same_v<MatrixType, COOMatrix<int, int>>) {
            inited = {
                1, 2, 3, 4, 5, 6, 7, 8, 9, 10
            };

        } else if constexpr(std::is_same_v<MatrixType, CSRMatrix<int, int>> ||
                            std::is_same_v<MatrixType, CSRCMatrix<int, int>>) {
            // CSR-likes

        } else if constexpr(std::is_same_v<MatrixType, DenseMatrix<int, int, char, true>> ||
                            std::is_same_v<MatrixType, DenseMatrixBitmask<int, int, char, true>>) {
            // Dense formats (row-major)

        } else if constexpr(std::is_same_v<MatrixType, DenseMatrix<int, int, char, false>> ||
                            std::is_same_v<MatrixType, DenseMatrixBitmask<int, int, char, false>>) {
            // Dense formats (column-major)

        } else if constexpr(std::is_same_v<MatrixType, ELLMatrix<int, int, true>> ||
                            std::is_same_v<MatrixType, ELLRMatrix<int, int, true>>) {
            // maxnzr = ..

        } else if constexpr(std::is_same_v<MatrixType, ELLMatrix<int, int, false>> ||
                            std::is_same_v<MatrixType, ELLRMatrix<int, int, false>>) {
            // maxnzr = ..

        } else if constexpr(std::is_same_v<MatrixType, LILMatrix<int, int>> ||
                            std::is_same_v<MatrixType, LILInvMatrix<int, int>>) {
            // LIL-likes

        } else if constexpr(std::is_same_v<MatrixType, SELLMatrix<int, int, true>>) {
            // Sliced ELLPACK with S=..

        } else {
            std::cout << "Matrix8x6_WithEmptyRows::generate_inited_matrix_variable: Non-implemented case ..." << std::endl;
        }

        return inited;
    }
    
    /**
     * @details     The matrix values are stored in a compressed fashion. However, the data container depends on the used format.
     *              This function generates the expected output, if a init_matrix_variable() function with a fixed value 1.0 has
     *              been called.
     */
    StorageType generate_expected_matrix_variable(int pattern) {
        StorageType expected;
        
        if constexpr(std::is_same_v<MatrixType, BSRMatrix<int, int, char, true>> ||
                     std::is_same_v<MatrixType, BSRMatrixBitmask<int, int, char, true>>) {
            // BSR formats
            switch (pattern)
            {
            case Pattern::INIT:
                break;

            case Pattern::SINGLE_POS:
                break;

            case Pattern::SINGLE_ROW:
                break;

            case Pattern::UPDATE_ALL:
                break;

            default:
                std::cout << "Non-implemented sub-pattern " << pattern << " ..." << std::endl;
                break;
            }

        } else if constexpr(std::is_same_v<MatrixType, COOMatrix<int, int>>) {
            // COO formats
            switch (pattern)
            {
            case Pattern::INIT:
                break;

            case Pattern::SINGLE_POS:
                break;

            case Pattern::SINGLE_ROW:
                break;

            case Pattern::UPDATE_ALL:
                break;

            default:
                std::cout << "Non-implemented sub-pattern " << pattern << " ..." << std::endl;
                break;
            }

        } else if constexpr(std::is_same_v<MatrixType, CSRMatrix<int, int>> ||
                            std::is_same_v<MatrixType, CSRCMatrix<int, int>>) {
            // CSR-likes
            switch (pattern)
            {
            case Pattern::INIT:
                break;

            case Pattern::SINGLE_POS:
                break;

            case Pattern::SINGLE_ROW:
                break;

            case Pattern::UPDATE_ALL:
                break;

            default:
                std::cout << "Non-implemented sub-pattern " << pattern << " ..." << std::endl;
                break;
            }

        } else if constexpr(std::is_same_v<MatrixType, DenseMatrix<int, int, char, true>> ||
                            std::is_same_v<MatrixType, DenseMatrixBitmask<int, int, char, true>>) {
            // Dense formats
            switch (pattern)
            {
            case Pattern::INIT:
                break;

            case Pattern::SINGLE_POS:
                break;

            case Pattern::SINGLE_ROW:
                break;

            case Pattern::UPDATE_ALL:
                break;

            default:
                std::cout << "Non-implemented sub-pattern " << pattern << " ..." << std::endl;
                break;
            }

        } else if constexpr(std::is_same_v<MatrixType, DenseMatrix<int, int, char, false>> ||
                            std::is_same_v<MatrixType, DenseMatrixBitmask<int, int, char, false>>) {
            // Dense formats
            switch (pattern)
            {
            case Pattern::INIT:
                break;

            case Pattern::SINGLE_POS:
                break;

            case Pattern::SINGLE_ROW:
                expected = {
                };
                break;

            case Pattern::UPDATE_ALL:
                expected = {
                };
                break;

            default:
                std::cout << "Non-implemented sub-pattern " << pattern << " ..." << std::endl;
                break;
            }

        } else if constexpr(std::is_same_v<MatrixType, ELLMatrix<int, int, true>> ||
                            std::is_same_v<MatrixType, ELLRMatrix<int, int, true>>) {
            // maxnzr = 4
            switch (pattern)
            {
            case Pattern::INIT:
                break;

            case Pattern::SINGLE_POS:
                break;

            case Pattern::SINGLE_ROW:
                break;

            case Pattern::UPDATE_ALL:
                break;

            default:
                std::cout << "Non-implemented sub-pattern " << pattern << " ..." << std::endl;
                break;
            }

        } else if constexpr(std::is_same_v<MatrixType, ELLMatrix<int, int, false>> ||
                            std::is_same_v<MatrixType, ELLRMatrix<int, int, false>>) {
            // maxnzr = 4
            switch (pattern)
            {
            case Pattern::INIT:
                break;

            case Pattern::SINGLE_POS:
                break;

            case Pattern::SINGLE_ROW:
                break;

            case Pattern::UPDATE_ALL:
                break;

            default:
                std::cout << "Non-implemented sub-pattern " << pattern << " ..." << std::endl;
                break;
            }

        } else if constexpr(std::is_same_v<MatrixType, LILMatrix<int, int>> ||
                            std::is_same_v<MatrixType, LILInvMatrix<int, int>>) {
            // LIL-likes
            switch (pattern)
            {
            case Pattern::INIT:
                break;

            case Pattern::SINGLE_POS:
                break;

            case Pattern::SINGLE_ROW:
                break;

            case Pattern::UPDATE_ALL:
                break;

            default:
                std::cout << "Non-implemented sub-pattern " << pattern << " ..." << std::endl;
                break;
            }
        } else if constexpr(std::is_same_v<MatrixType, SELLMatrix<int, int, true>>) {
            // Sliced ELLPACK with S=3
            switch (pattern)
            {
            case Pattern::INIT:
                break;

            case Pattern::SINGLE_POS:
                break;

            case Pattern::SINGLE_ROW:
                break;

            case Pattern::UPDATE_ALL:
                break;

            default:
                std::cout << "Non-implemented sub-pattern " << pattern << " ..." << std::endl;
                break;
            }
        } else {
            std::cout << "Matrix8x6_WithEmptyRows::generate_expected_matrix_variable: Non-implemented case ..." << std::endl;
        }

        return expected;
    }
};

// Add the SpMV implementations, see MatrixCommon.hpp for a list of formats.
TYPED_TEST_SUITE(Matrix8x6_WithEmptyRows, MatrixImplementations);

/********************************************************************************************/
/*  Represent the non-zeros aka connectivity                                                */
/********************************************************************************************/

TYPED_TEST(Matrix8x6_WithEmptyRows, InitConnectivity) {
    // dense sizes
    EXPECT_EQ(this->mat_->num_rows(), 8);
    EXPECT_EQ(this->mat_->num_columns(), 6);
}

TYPED_TEST(Matrix8x6_WithEmptyRows, PostRanksAccessor) {
    // read-out
    auto post_ranks = this->mat_->get_post_rank();

    // Top-level vectors equal in size?
    EXPECT_EQ(this->post_ranks_.size(), post_ranks.size());

    // Compare the content of the vectors
    auto post_it1 = this->post_ranks_.cbegin();
    auto post_it2 = post_ranks.cbegin();

    for(; post_it1 != this->post_ranks_.cend(); ++post_it1, ++post_it2) {
        EXPECT_EQ(*post_it1, *post_it2);
    }
}

TYPED_TEST(Matrix8x6_WithEmptyRows, PreRanksAccessor) {
    // read-out column indices, placed row-wise in vectors
    auto pre_ranks = this->mat_->get_pre_ranks();

    // Top-level vectors equal in size?
    EXPECT_EQ(this->pre_ranks_.size(), pre_ranks.size());

    // Compare for each sub-vector if they are equal in size?
    auto pre_it1 = this->pre_ranks_.cbegin();
    auto pre_it2 = pre_ranks.cbegin();

    for(; pre_it1 != this->pre_ranks_.cend(); ++pre_it1, ++pre_it2) {
        EXPECT_EQ(pre_it1->size(), pre_it2->size());
    }

    // Last, we compare the column indices, row-by-row
    pre_it1 = this->pre_ranks_.cbegin();
    pre_it2 = pre_ranks.cbegin();
    for(; pre_it1 != this->pre_ranks_.cend(); ++pre_it1, ++pre_it2) {
        auto pre_sub_it1 = pre_it1->cbegin();
        auto pre_sub_it2 = pre_it2->cbegin();

        for(; pre_sub_it1 != pre_it1->cend(); ++pre_sub_it1, ++pre_sub_it2) {
            EXPECT_EQ(*pre_sub_it1, *pre_sub_it2);
        }
    }
}

TYPED_TEST(Matrix8x6_WithEmptyRows, GetNumberOfDendrites) {
    // Compare number of rows with non-zeros
    EXPECT_EQ(this->mat_->nb_dendrites(), this->pre_ranks_.size());
}

TYPED_TEST(Matrix8x6_WithEmptyRows, GetNumberOfSynapses) {
    // How many non-zeros
    int nnz = 0;
    for (auto it = this->pre_ranks_.cbegin(); it != this->pre_ranks_.cend(); ++it)
        nnz += it->size();

    EXPECT_EQ(this->mat_->nb_synapses(), nnz);
}

TYPED_TEST(Matrix8x6_WithEmptyRows, GetDendriteSize) {
    // compare row-lengths (note need to access with LIL index)
    int i = 0;
    for (auto it = this->pre_ranks_.cbegin(); it != this->pre_ranks_.cend(); ++it, ++i)
        EXPECT_EQ(it->size(), this->mat_->dendrite_size(i));
}

TYPED_TEST(Matrix8x6_WithEmptyRows, GetDendriteRanks) {
    // compare the access to a specific row
    auto exp_pre_ranks = this->pre_ranks_[1];
    auto act_pre_ranks = this->mat_->get_dendrite_pre_rank(1);

    EXPECT_EQ(exp_pre_ranks.size(), act_pre_ranks.size());

    auto it1 = exp_pre_ranks.cbegin();
    auto it2 = act_pre_ranks.cbegin();

    for (; it1 != exp_pre_ranks.cend(); ++it1, ++it2) {
        EXPECT_EQ(*it1, *it2);
    }
}

/********************************************************************************************/
/*  Initialize matrix values                                                                */
/********************************************************************************************/

/*
TYPED_TEST(Matrix8x6_WithEmptyRows, InitMatrixWithOneValue) {
    // Reference
    auto expected = this->generate_expected_matrix_variable(Pattern::INIT);
    
    // create a matrix variable
    auto actual = this->mat_->template init_matrix_variable<double>(1.0);

    // has the returned variable the correct size?
    EXPECT_EQ(expected.size(), actual.size());

    // Is the content correct?
    auto it1 = expected.cbegin();
    auto it2 = actual.cbegin();
    size_t num_mismatches = 0;

    for (; it1 != expected.cend(); ++it1, ++it2) {
        if (*it1 != *it2) {
            num_mismatches++;
        }
    }
    EXPECT_EQ(num_mismatches, 0);
}

TYPED_TEST(Matrix8x6_WithEmptyRows, InitMatrixWithUniform) {
    std::mt19937 rng;

    // TODO: this is not clean, I assume here that init_matrix_variable() is implemented correctly...
    auto expected = this->mat_->template init_matrix_variable<double>(1.0);
    auto actual = this->mat_->template init_matrix_variable_uniform<double>(0.0, 1.0, rng);

    // has the returned variable the correct size?
    EXPECT_EQ(expected.size(), actual.size());
}
*/

/********************************************************************************************/
/*  Update matrix values                                                                    */
/********************************************************************************************/

/*
TYPED_TEST(Matrix8x6_WithEmptyRows, UpdateMatrixSinglePosition) {
    // Reference
    auto expected = this->generate_expected_matrix_variable(Pattern::SINGLE_POS);
    
    // create a matrix variable
    auto matrix_variable = this->mat_->template init_matrix_variable<double>(1.0);

    // Try to update the matrix.
    this->mat_->template update_matrix_variable<double>(matrix_variable, 1, 4, 3.0);

    // Was the update successful?
    auto it1 = expected.cbegin();
    auto it2 = matrix_variable.cbegin();
    size_t num_mismatches = 0;

    for (; it1 != expected.cend(); ++it1, ++it2) {
        if (*it1 != *it2) {
            num_mismatches++;
        }
    }
    EXPECT_EQ(num_mismatches, 0);
}

TYPED_TEST(Matrix8x6_WithEmptyRows, UpdateMatrixSingleRow) {
    // Reference
    auto expected = this->generate_expected_matrix_variable(Pattern::SINGLE_ROW);
    
    // create a matrix variable
    auto matrix_variable = this->mat_->template init_matrix_variable<double>(1.0);

    // Try to update the matrix.
    std::vector<double> new_w = {2.0, 3.0, 3.0, 2.0};
    this->mat_->template update_matrix_variable_row<double>(matrix_variable, 1, new_w);

    // Was the update successful?
    auto it1 = expected.cbegin();
    auto it2 = matrix_variable.cbegin();
    bool equal = true;

    for (; it1 != expected.cend(); ++it1, ++it2) {
        if (*it1 != *it2) {
            equal = false;
            break;
        }
    }
    EXPECT_EQ(equal, true);
}

TYPED_TEST(Matrix8x6_WithEmptyRows, UpdateMatrixAllAtOnce) {
    // Init variable
    auto matrix_variable = this->mat_->template init_matrix_variable<double>(1.0);

    // Reference
    auto expected = this->generate_expected_matrix_variable(Pattern::UPDATE_ALL);

    // Try to update the matrix. There is an overlap with UpdateOneRow,
    // but the sanity checks are performed anyways.
    auto new_values_as_lil = std::vector<std::vector<double>>();
    new_values_as_lil.push_back({2.0, 2.0});
    new_values_as_lil.push_back({2.0, 3.0, 3.0, 2.0});
    new_values_as_lil.push_back({2.0, 2.0});
    new_values_as_lil.push_back({2.0, 2.0});
    this->mat_->template update_matrix_variable_all<double>(matrix_variable, new_values_as_lil);

    // Was the update successful?
    auto it1 = expected.cbegin();
    auto it2 = matrix_variable.cbegin();
    bool equal = true;

    for (; it1 != expected.cend(); ++it1, ++it2) {
        if (*it1 != *it2) {
            equal = false;
            break;
        }
    }
    EXPECT_EQ(equal, true);
}
*/

/********************************************************************************************/
/*  Read-out the matrix variable as LIL                                                     */
/********************************************************************************************/

/*
TYPED_TEST(Matrix8x6_WithEmptyRows, GetMatrixSinglePosition) {
    auto variable = this->generate_inited_matrix_variable();

    auto value = this->mat_->template get_matrix_variable<double>(variable, 1, 4);

    EXPECT_EQ(value, 4.0);
}

// Note: this function is often implicitly called by get_matrix_variable_all, so one
// could technically leave it out, but it won't hurt anyways ...
TYPED_TEST(Matrix8x6_WithEmptyRows, GetMatrixSingleRow) {

    auto variable_inited = this->generate_inited_matrix_variable();

    // retrieve a single row. note we need to use lil_idx: 3rd row (dense) -> 1st row (sparse)
    auto exp_values = std::vector<double>({3,4,5,6});
    auto ret_values = this->mat_->template get_matrix_variable_row<double>(variable_inited, 1);

    // compare size
    EXPECT_EQ(exp_values.size(), ret_values.size());

    // compare content
    auto it1 = exp_values.cbegin();
    auto it2 = ret_values.cbegin();
    for(; it1 != exp_values.cend(); ++it1, ++it2)
        EXPECT_EQ(*it1, *it2);
}

TYPED_TEST(Matrix8x6_WithEmptyRows, GetMatrixAllAtOnce) {
    auto expected = this->values_;

    auto variable_inited = this->generate_inited_matrix_variable();
    auto variable_as_lil = this->mat_->template get_matrix_variable_all<double>(variable_inited);

    auto pre_it1 = expected.cbegin();
    auto pre_it2 = variable_as_lil.cbegin();

    for(; pre_it1 != expected.cend(); ++pre_it1, ++pre_it2) {
        EXPECT_EQ(pre_it1->size(), pre_it2->size());
    }

    pre_it1 = expected.cbegin();
    pre_it2 = variable_as_lil.cbegin();
    for(; pre_it1 != expected.cend(); ++pre_it1, ++pre_it2) {
        auto pre_sub_it1 = pre_it1->cbegin();
        auto pre_sub_it2 = pre_it2->cbegin();

        for(; pre_sub_it1 != pre_it1->cend(); ++pre_sub_it1, ++pre_sub_it2) {
            EXPECT_EQ(*pre_sub_it1, *pre_sub_it2);
        }
    }    
}
*/

/********************************************************************************************/
/*  Initialize vector values                                                                */
/********************************************************************************************/

/*
TYPED_TEST(Matrix8x6_WithEmptyRows, InitVectorWithOneValue) {
    using MatrixType = typename TypeParam::MatrixClassType;

    auto variable_vec = this->mat_->template init_vector_variable<double>(1.0);

    if constexpr(std::is_same_v<MatrixType, DenseMatrix<int, int, char, true>> || std::is_same_v<MatrixType, DenseMatrixBitmask<int, int, char, true>> ||
                 std::is_same_v<MatrixType, DenseMatrix<int, int, char, false>> || std::is_same_v<MatrixType, DenseMatrixBitmask<int, int, char, false>>) 
    {
        // Special case: The variable should contain one space for each row.
        EXPECT_EQ(variable_vec.size(), this->mat_->num_rows());
    } else {
        // The variable should contain one space for each existing dendrite.
        EXPECT_EQ(variable_vec.size(), this->mat_->nb_dendrites());
    }
}
*/
