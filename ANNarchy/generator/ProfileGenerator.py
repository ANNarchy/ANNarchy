import ANNarchy.core.Global as Global
from .Template.ProfileTemplate import profile_template

class ProfileGenerator(object):
    """
    Extent the generated code by profiling annotations.
    """
    def __init__(self, annarchy_dir):
        """
        Initialize ProfileGenerator.
        """
        self.annarchy_dir = annarchy_dir

    def generate(self):
        """
        Generate Profiling class code, called from Generator instance.
        """
        # Generate header for profiling
        with open(self.annarchy_dir+'/generate/Profiling.h', 'w') as ofile:
            ofile.write(self._generate_header())

    def generate_init_population(self, pop):
        """
        Generate initialization code
        """
        declare = """
    Measurement* measure_step;
"""
        init = """        // Profiling
        measure_step = Profiling::get_instance()->register_function("%(name)s", "step");
""" % { 'name': pop.name }

        return declare, init

    def annotate_computesum_rate_omp(self, proj, code):
        """
        annotate the computesum compuation code
        """
        prof_begin = profile_template['compute_psp']['before'] % { 'name': 'proj'+str(proj.id) }
        prof_end = profile_template['compute_psp']['after'] % { 'name': 'proj'+str(proj.id) }

        prof_code = """
        // first run, measuring average time
        %(prof_begin)s
%(code)s
        %(prof_end)s
""" % {'code': code,
       'prof_begin': prof_begin,
       'prof_end': prof_end
       }
        return prof_code

    def annotate_computesum_spiking_omp(self, proj, code):
        """
        annotate the computesum compuation code
        """
        prof_begin = profile_template['compute_psp']['before'] % { 'name': 'proj'+str(proj.id) }
        prof_end = profile_template['compute_psp']['after'] % { 'name': 'proj'+str(proj.id) }

        prof_code = """
        // first run, measuring average time
        %(prof_begin)s
%(code)s
        %(prof_end)s
""" % {'code': code,
       'prof_begin': prof_begin,
       'prof_end': prof_end
       }
        return prof_code

    def annotate_update_synapse_omp(self, proj, code):
        """
        annotate the update synapse code, generated by ProjectionGenerator.update_synapse()
        """
        prof_begin = profile_template['update_synapse']['before'] % { 'name': 'proj'+str(proj.id) }
        prof_end = profile_template['update_synapse']['after'] % { 'name': 'proj'+str(proj.id) }

        if code != "":
            prof_code = """
            // first run, measuring average time
            %(prof_begin)s
%(code)s
        %(prof_end)s
""" % {'code': code,
       'prof_begin': prof_begin,
       'prof_end': prof_end
       }

        else:
            prof_code = "       rc++; // nothing to measure"

        return prof_code

    def annotate_update_neuron_omp(self, pop, code):
        """
        annotate the update neuron code
        """
        prof_begin = profile_template['update_neuron']['before'] % { 'name': pop.name }
        prof_end = profile_template['update_neuron']['after'] % { 'name': pop.name }

        prof_code = """
        // first run, measuring average time
        %(prof_begin)s
%(code)s
        %(prof_end)s
""" % {'code': code,
       'prof_begin': prof_begin,
       'prof_end': prof_end
       }
        return prof_code

    def _generate_header(self):
        """
        generate Profiling.h
        """
        from .Template.ProfileTemplate import profile_header
        if Global.config["paradigm"] == "openmp":
            return profile_header
        else:
            return ""
