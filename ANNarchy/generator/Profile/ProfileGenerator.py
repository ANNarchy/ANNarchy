import ANNarchy.core.Global as Global
from .Template import profile_generator_omp_template

class ProfileGenerator(object):
    """
    Extent the generated code by profiling annotations.
    """
    def __init__(self, annarchy_dir, populations, projections):
        
        self.annarchy_dir = annarchy_dir
        self._populations = populations
        self._projections = projections
        self._num_ops = 0
        self._calculate_num_ops()

    def generate(self):
        """
        Generate Profiling class code, called from Generator instance.
        """
        # Generate header for profiling
        with open(self.annarchy_dir+'/generate/Profiling.h', 'w') as ofile:
            ofile.write(self._generate_header())

        # Generate cpp for profiling
        with open(self.annarchy_dir+'/generate/Profiling.cpp', 'w') as ofile:
            ofile.write(self._generate_body())

    def get_num_ops(self):
        """
        Returns the amount of measured operations
        """
        return self._num_ops

    def annotate_computesum_rate_omp(self, code):
        """
        annotate the computesum compuation code
        """
        prof_begin = profile_generator_omp_template['compute_psp']['before'] % { 'num_ops': self._num_ops, 'off': "(rc %"+str(self._num_ops)+")" }
        prof_end = profile_generator_omp_template['compute_psp']['after'] % { 'num_ops': self._num_ops, 'off': "(rc %"+str(self._num_ops)+")" }

        prof_code = """
        // first run, measuring average time
        %(prof_begin)s
%(code)s
        %(prof_end)s
""" % {'code': code,
       'prof_begin': prof_begin,
       'prof_end': prof_end
       }
        return prof_code

    def annotate_computesum_spiking_omp(self, code):
        """
        annotate the computesum compuation code
        """
        prof_begin = profile_generator_omp_template['compute_psp']['before'] % { 'num_ops': self._num_ops, 'off': "(rc %"+str(self._num_ops)+")" }
        prof_end = profile_generator_omp_template['compute_psp']['after'] % { 'num_ops': self._num_ops, 'off': "(rc %"+str(self._num_ops)+")" }

        prof_code = """
        // first run, measuring average time
        %(prof_begin)s
%(code)s
        %(prof_end)s
""" % {'code': code,
       'prof_begin': prof_begin,
       'prof_end': prof_end
       }
        return prof_code

    def annotate_update_synapse_omp(self, code):
        """
        annotate the update synapse code, generated by ProjectionGenerator.update_synapse()
        """
        prof_begin = profile_generator_omp_template['update_synapse']['before'] % { 'num_ops': self._num_ops }
        prof_end = profile_generator_omp_template['update_synapse']['after'] % { 'num_ops': self._num_ops }

        if code != "":
            prof_code = """
            // first run, measuring average time
            %(prof_begin)s
%(code)s
        %(prof_end)s
""" % {'code': code,
       'prof_begin': prof_begin,
       'prof_end': prof_end
       }

        else:
            prof_code = "       rc++; // nothing to measure"

        return prof_code

    def annotate_update_neuron_omp(self, code):
        """
        annotate the update neuron code
        """
        prof_begin = profile_generator_omp_template['update_neuron']['before'] % { 'num_ops': self._num_ops }
        prof_end = profile_generator_omp_template['update_neuron']['after'] % { 'num_ops': self._num_ops }

        prof_code = """
        // first run, measuring average time
        %(prof_begin)s
%(code)s
        %(prof_end)s
""" % {'code': code,
       'prof_begin': prof_begin,
       'prof_end': prof_end
       }
        return prof_code

    def annotate_spike_propagation_omp(self, code):
        """
        annotate the spike propagation code
        """
        prof_begin = profile_generator_omp_template['update_neuron']['before'] % { 'num_ops': self._num_ops }
        prof_end = profile_generator_omp_template['update_neuron']['after'] % { 'num_ops': self._num_ops }

        prof_code = """
        // first run, measuring average time
        %(prof_begin)s
%(code)s
        %(prof_end)s
""" % {'code': code,
       'prof_begin': prof_begin,
       'prof_end': prof_end
       }
        return prof_code

    def _calculate_num_ops(self):
        """
        Determine the number of operations need to be profiled
        """
        for proj in Global._network[0]['projections']:
            self._num_ops += 2 # compute_sum, update_synapse

        for pop in Global._network[0]['populations']:
            self._num_ops += 1 # update_neuron
            if pop.neuron_type.type == "spike":
                self._num_ops += 1 # spike propagation

    def _generate_header(self):
        """
        generate Profiling.h
        """
        from .HeaderTemplate import openmp_profile_header, cuda_profile_header
        if Global.config["paradigm"] == "openmp":
            return openmp_profile_header
        else:
            return cuda_profile_header
    
    def _generate_body(self):
        """
        generate Profiling.cpp
        """
        num_threads = 12  #TODO: replace
        
        # count initialization
        name = ""   # performance container
        add = ""    # additional tags
        rc = 0

        #
        # CPU_time_container
        for proj in Global._network[0]['projections']:    # compute sum
            name += """        set_CPU_time_name( i*%(num_op)s+%(off)s,"Proj%(id)s - compute sum");
            set_CPU_time_related_time( i*%(num_op)s+%(off)s, i );
            set_total_cache_miss_name( i*%(num_op)s+%(off)s,"Proj%(id)s - compute sum - cache miss");
""" % { 'id': proj.id, 'num_op': self._num_ops, 'off': rc }
            rc+= 1

        for pop in Global._network[0]['populations']:     # neural update
            name += """        set_CPU_time_name( i*%(num_op)s+%(off)s,"%(name)s - neural update");
            set_CPU_time_related_time( i*%(num_op)s+%(off)s, i );
""" % { 'name': pop.name, 'num_op': self._num_ops, 'off': rc }
            rc+= 1
            if pop.neuron_type.type == "spike":
                name += """        set_CPU_time_name( i*%(num_op)s+%(off)s,"%(name)s - spike gathering");
                set_CPU_time_related_time( i*%(num_op)s+%(off)s, i );
""" % { 'name': pop.name, 'num_op': self._num_ops, 'off': rc }
                rc+= 1

        for proj in Global._network[0]['projections']:    # update synapses
            name += """        set_CPU_time_name( i*%(num_op)s+%(off)s,"Proj%(id)s - update synapses");
            set_CPU_time_related_time( i*%(num_op)s+%(off)s, i );
""" % { 'id': proj.id, 'num_op': self._num_ops, 'off': rc }
            rc+= 1

        rc = 0
        #
        # CPU_time_additional strings
        for proj in Global._network[0]['projections']:    # compute sum
            add += """        set_CPU_time_additional( i*%(num_op)s+%(off)s, s);
        set_total_cache_miss_additional( i*%(num_op)s+%(off)s, s);
""" % { 'num_op': self._num_ops, 'off': rc }
            rc+= 1

        for pop in Global._network[0]['populations']:     # neural update
            add += """        set_CPU_time_additional( i*%(num_op)s+%(off)s, s);
""" % { 'num_op': self._num_ops, 'off': rc }
            rc+= 1
            if pop.neuron_type.type == "spike":
                add += """        set_CPU_time_additional( i*%(num_op)s+%(off)s, s);
""" % { 'num_op': self._num_ops, 'off': rc }
                rc+= 1

        for proj in Global._network[0]['projections']:    # update synapses
            add += """        set_CPU_time_additional( i*%(num_op)s+%(off)s, s);
""" % { 'num_op': self._num_ops, 'off': rc }
            rc+= 1

        #
        # complete initialization listing
        init = """
        // setup counter
        set_CPU_time_number( %(num_op)s * %(num_thread)s );
        set_total_cache_miss_number( %(num_op)s * %(num_thread)s );
        set_overall_number( %(num_thread)s );
""" % { 'num_op': self._num_ops,
        'num_thread': num_threads,
       }

        init2 = """
    for ( int i = 0; i < %(num_threads)s; i++ )
    {
        // outlier
        set_CPU_time_hight_outlier_count(i, 0);
        set_CPU_time_low_outlier_count(i, 0);
    
        // set names
%(name)s

        // set additonal
        std::string s = std::to_string(i+1);
        s+=";Threads";
%(add)s
    }
""" % { 'num_threads': num_threads,
        'name': name,
        'add': add 
       }
         
        from .BodyTemplate import openmp_profile_body, cuda_profile_body
        if Global.config["paradigm"] == "openmp":
            code = openmp_profile_body % { 'init': init, 'init2': init2  }
            return code
        else:
            return cuda_profile_body 
    