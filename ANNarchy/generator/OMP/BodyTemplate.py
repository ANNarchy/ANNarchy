body_template = '''
#include "ANNarchy.h"

/*
 * Internal data
 *
*/
double dt;
long int t;

// Random number generators
std::vector< std::mt19937 >  rng;
std::uniform_real_distribution<double> uniform;
std::normal_distribution<double> normal;

// Populations
%(pop_ptr)s

// Projections
%(proj_ptr)s

// Simulate the network for the given number of steps
void run(int nbSteps) {

    for(int i=0; i<nbSteps; i++)
    {
        step();
    }

}

// Initialize the internal data and random numbers generators
void initialize(double _dt) {

    dt = _dt;
    t = 0;

    for(int seed = 0; seed < std::max(1, omp_get_max_threads()); ++seed)
    {
        rng.push_back(std::mt19937(time(NULL)*seed));
    }
    uniform =  std::uniform_real_distribution<double>(0.0, 1.0);
    normal =  std::normal_distribution<double>(0.0, 1.0);
}

// Step method. Generated by ANNarchy.
void step()
{

    ////////////////////////////////
    // Presynaptic events
    ////////////////////////////////
    int pre_rank, post_rank;
    double start;
%(compute_sums)s

    ////////////////////////////////
    // Reset spikes
    ////////////////////////////////


    ////////////////////////////////
    // Update neural variables
    ////////////////////////////////
%(update_neuron)s    

    ////////////////////////////////
    // Global operations (min/max/mean)
    ////////////////////////////////

    ////////////////////////////////
    // Update synaptic variables
    ////////////////////////////////


    ////////////////////////////////
    // Postsynaptic events
    ////////////////////////////////

    ////////////////////////////////
    // Recording
    ////////////////////////////////

    ////////////////////////////////
    // Increase internal time
    ////////////////////////////////
    t++;
}


/*
 * Connectivity methods
 *
*/
BaseProjection flattenConnectivityMatrix(
    int size,
    std::vector<int> post, 
    std::vector< std::vector <int> > pre, 
    std::vector< std::vector <double> > w, 
    std::vector< std::vector <int> > delay )
{

    BaseProjection proj;
    proj.post_rank = std::vector<int>(0,0);
    proj.pre_rank = std::vector<int>(0,0);
    proj.w = std::vector<double>(0,0.0);
    proj.delay = std::vector<int>(0,0);

    int total_size = 0;
    int nb_syn = 0;
    for(int i=0; i< post.size(); i++)
    {
        // Number of synapses
        nb_syn = pre[i].size();
        total_size += nb_syn;
        // Add the post ranks
        std::vector<int> tmp_post = std::vector<int>(nb_syn, post[i]);
        proj.post_rank.insert(proj.post_rank.end(), tmp_post.begin(), tmp_post.end());
        // Add the pre ranks
        proj.pre_rank.insert(proj.pre_rank.end(), pre[i].begin(), pre[i].end());
        // Add the weights. Warning: there may be only one element if they are all the same.
        if(w[i].size()==1){
            std::vector<double> tmp_w = std::vector<double>(nb_syn, w[i][0]);
            proj.w.insert(proj.w.end(), tmp_w.begin(), tmp_w.end());
        }
        else{
            proj.w.insert(proj.w.end(), w[i].begin(), w[i].end());
        }
        // Add the delays. Warning: there may be only one element if they are all the same.
        if(delay[i].size()==1){
            std::vector<int> tmp_delay = std::vector<int>(nb_syn, delay[i][0]);
            proj.delay.insert(proj.delay.end(), tmp_delay.begin(), tmp_delay.end());
        }
        else{
            proj.delay.insert(proj.delay.end(), delay[i].begin(), delay[i].end());
        }
    }
    if(total_size!=size){
        std::cout << "ERROR: the CSR object is corrupted..." << std::endl;
        exit (EXIT_FAILURE);
    }

    return proj;
}


/*
 * Access to time and dt
 *
*/
int getTime() {return int(t);}
void setTime(int t_) { t=(long int)(t_);}
double getDt() { return dt;}
void setDt(double dt_) { dt=dt_;}

/*
 * Number of threads
 *
*/
void setNumThreads(int threads)
{
    omp_set_num_threads(threads);
}
'''