# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.40
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.
# This file is compatible with both classic and new-style classes.

from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_almath', [dirname(__file__)])
        except ImportError:
            import _almath
            return _almath
        if fp is not None:
            try:
                _mod = imp.load_module('_almath', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _almath = swig_import_helper()
    del swig_import_helper
else:
    import _almath
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _almath.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self):
        """value(self) -> PyObject"""
        return _almath.SwigPyIterator_value(self)

    def incr(self, n = 1):
        """
        incr(self, size_t n = 1) -> SwigPyIterator
        incr(self) -> SwigPyIterator
        """
        return _almath.SwigPyIterator_incr(self, n)

    def decr(self, n = 1):
        """
        decr(self, size_t n = 1) -> SwigPyIterator
        decr(self) -> SwigPyIterator
        """
        return _almath.SwigPyIterator_decr(self, n)

    def distance(self, *args):
        """distance(self, SwigPyIterator x) -> ptrdiff_t"""
        return _almath.SwigPyIterator_distance(self, *args)

    def equal(self, *args):
        """equal(self, SwigPyIterator x) -> bool"""
        return _almath.SwigPyIterator_equal(self, *args)

    def copy(self):
        """copy(self) -> SwigPyIterator"""
        return _almath.SwigPyIterator_copy(self)

    def next(self):
        """next(self) -> PyObject"""
        return _almath.SwigPyIterator_next(self)

    def __next__(self):
        """__next__(self) -> PyObject"""
        return _almath.SwigPyIterator___next__(self)

    def previous(self):
        """previous(self) -> PyObject"""
        return _almath.SwigPyIterator_previous(self)

    def advance(self, *args):
        """advance(self, ptrdiff_t n) -> SwigPyIterator"""
        return _almath.SwigPyIterator_advance(self, *args)

    def __eq__(self, *args):
        """__eq__(self, SwigPyIterator x) -> bool"""
        return _almath.SwigPyIterator___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, SwigPyIterator x) -> bool"""
        return _almath.SwigPyIterator___ne__(self, *args)

    def __iadd__(self, *args):
        """__iadd__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _almath.SwigPyIterator___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _almath.SwigPyIterator___isub__(self, *args)

    def __add__(self, *args):
        """__add__(self, ptrdiff_t n) -> SwigPyIterator"""
        return _almath.SwigPyIterator___add__(self, *args)

    def __sub__(self, *args):
        """
        __sub__(self, ptrdiff_t n) -> SwigPyIterator
        __sub__(self, SwigPyIterator x) -> ptrdiff_t
        """
        return _almath.SwigPyIterator___sub__(self, *args)

    def __iter__(self): return self
SwigPyIterator_swigregister = _almath.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class vectorFloat(_object):
    """Proxy of C++ std::vector<(float)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorFloat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorFloat, name)
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _almath.vectorFloat_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _almath.vectorFloat___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _almath.vectorFloat___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _almath.vectorFloat___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _almath.vectorFloat_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> vectorFloat"""
        return _almath.vectorFloat___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, vectorFloat v)"""
        return _almath.vectorFloat___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _almath.vectorFloat___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _almath.vectorFloat___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> vectorFloat
        __getitem__(self, difference_type i) -> value_type
        """
        return _almath.vectorFloat___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, vectorFloat v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _almath.vectorFloat___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _almath.vectorFloat_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _almath.vectorFloat_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _almath.vectorFloat_size(self)

    def clear(self):
        """clear(self)"""
        return _almath.vectorFloat_clear(self)

    def swap(self, *args):
        """swap(self, vectorFloat v)"""
        return _almath.vectorFloat_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _almath.vectorFloat_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _almath.vectorFloat_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _almath.vectorFloat_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _almath.vectorFloat_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _almath.vectorFloat_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _almath.vectorFloat_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _almath.vectorFloat_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> vectorFloat
        __init__(self, vectorFloat arg0) -> vectorFloat
        __init__(self, size_type size) -> vectorFloat
        __init__(self, size_type size, value_type value) -> vectorFloat
        """
        this = _almath.new_vectorFloat(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _almath.vectorFloat_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _almath.vectorFloat_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _almath.vectorFloat_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _almath.vectorFloat_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _almath.vectorFloat_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _almath.vectorFloat_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _almath.vectorFloat_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _almath.vectorFloat_capacity(self)

    def __repr__(self):
        """__repr__(self) -> string"""
        return _almath.vectorFloat___repr__(self)

    __swig_destroy__ = _almath.delete_vectorFloat
    __del__ = lambda self : None;
vectorFloat_swigregister = _almath.vectorFloat_swigregister
vectorFloat_swigregister(vectorFloat)

class vectorPosition2D(_object):
    """Proxy of C++ std::vector<(AL::Math::Position2D)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorPosition2D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorPosition2D, name)
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _almath.vectorPosition2D_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _almath.vectorPosition2D___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _almath.vectorPosition2D___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _almath.vectorPosition2D___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _almath.vectorPosition2D_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> vectorPosition2D"""
        return _almath.vectorPosition2D___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, vectorPosition2D v)"""
        return _almath.vectorPosition2D___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _almath.vectorPosition2D___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _almath.vectorPosition2D___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> vectorPosition2D
        __getitem__(self, difference_type i) -> value_type
        """
        return _almath.vectorPosition2D___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, vectorPosition2D v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _almath.vectorPosition2D___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _almath.vectorPosition2D_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _almath.vectorPosition2D_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _almath.vectorPosition2D_size(self)

    def clear(self):
        """clear(self)"""
        return _almath.vectorPosition2D_clear(self)

    def swap(self, *args):
        """swap(self, vectorPosition2D v)"""
        return _almath.vectorPosition2D_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _almath.vectorPosition2D_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _almath.vectorPosition2D_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _almath.vectorPosition2D_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _almath.vectorPosition2D_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _almath.vectorPosition2D_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _almath.vectorPosition2D_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _almath.vectorPosition2D_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> vectorPosition2D
        __init__(self, vectorPosition2D arg0) -> vectorPosition2D
        __init__(self, size_type size) -> vectorPosition2D
        __init__(self, size_type size, value_type value) -> vectorPosition2D
        """
        this = _almath.new_vectorPosition2D(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _almath.vectorPosition2D_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _almath.vectorPosition2D_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _almath.vectorPosition2D_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _almath.vectorPosition2D_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _almath.vectorPosition2D_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _almath.vectorPosition2D_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _almath.vectorPosition2D_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _almath.vectorPosition2D_capacity(self)

    def __repr__(self):
        """__repr__(self) -> string"""
        return _almath.vectorPosition2D___repr__(self)

    __swig_destroy__ = _almath.delete_vectorPosition2D
    __del__ = lambda self : None;
vectorPosition2D_swigregister = _almath.vectorPosition2D_swigregister
vectorPosition2D_swigregister(vectorPosition2D)

class vectorPose2D(_object):
    """Proxy of C++ std::vector<(AL::Math::Pose2D)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorPose2D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorPose2D, name)
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _almath.vectorPose2D_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _almath.vectorPose2D___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _almath.vectorPose2D___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _almath.vectorPose2D___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _almath.vectorPose2D_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> vectorPose2D"""
        return _almath.vectorPose2D___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, vectorPose2D v)"""
        return _almath.vectorPose2D___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _almath.vectorPose2D___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _almath.vectorPose2D___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> vectorPose2D
        __getitem__(self, difference_type i) -> value_type
        """
        return _almath.vectorPose2D___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, vectorPose2D v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _almath.vectorPose2D___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _almath.vectorPose2D_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _almath.vectorPose2D_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _almath.vectorPose2D_size(self)

    def clear(self):
        """clear(self)"""
        return _almath.vectorPose2D_clear(self)

    def swap(self, *args):
        """swap(self, vectorPose2D v)"""
        return _almath.vectorPose2D_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _almath.vectorPose2D_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _almath.vectorPose2D_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _almath.vectorPose2D_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _almath.vectorPose2D_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _almath.vectorPose2D_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _almath.vectorPose2D_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _almath.vectorPose2D_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> vectorPose2D
        __init__(self, vectorPose2D arg0) -> vectorPose2D
        __init__(self, size_type size) -> vectorPose2D
        __init__(self, size_type size, value_type value) -> vectorPose2D
        """
        this = _almath.new_vectorPose2D(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _almath.vectorPose2D_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _almath.vectorPose2D_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _almath.vectorPose2D_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _almath.vectorPose2D_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _almath.vectorPose2D_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _almath.vectorPose2D_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _almath.vectorPose2D_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _almath.vectorPose2D_capacity(self)

    def __repr__(self):
        """__repr__(self) -> string"""
        return _almath.vectorPose2D___repr__(self)

    __swig_destroy__ = _almath.delete_vectorPose2D
    __del__ = lambda self : None;
vectorPose2D_swigregister = _almath.vectorPose2D_swigregister
vectorPose2D_swigregister(vectorPose2D)

class vectorPosition6D(_object):
    """Proxy of C++ std::vector<(AL::Math::Position6D)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorPosition6D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorPosition6D, name)
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _almath.vectorPosition6D_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _almath.vectorPosition6D___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _almath.vectorPosition6D___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _almath.vectorPosition6D___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _almath.vectorPosition6D_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> vectorPosition6D"""
        return _almath.vectorPosition6D___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(self, difference_type i, difference_type j, vectorPosition6D v)"""
        return _almath.vectorPosition6D___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _almath.vectorPosition6D___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _almath.vectorPosition6D___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> vectorPosition6D
        __getitem__(self, difference_type i) -> value_type
        """
        return _almath.vectorPosition6D___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, vectorPosition6D v)
        __setitem__(self, difference_type i, value_type x)
        """
        return _almath.vectorPosition6D___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _almath.vectorPosition6D_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _almath.vectorPosition6D_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _almath.vectorPosition6D_size(self)

    def clear(self):
        """clear(self)"""
        return _almath.vectorPosition6D_clear(self)

    def swap(self, *args):
        """swap(self, vectorPosition6D v)"""
        return _almath.vectorPosition6D_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _almath.vectorPosition6D_get_allocator(self)

    def begin(self):
        """begin(self) -> const_iterator"""
        return _almath.vectorPosition6D_begin(self)

    def end(self):
        """end(self) -> const_iterator"""
        return _almath.vectorPosition6D_end(self)

    def rbegin(self):
        """rbegin(self) -> const_reverse_iterator"""
        return _almath.vectorPosition6D_rbegin(self)

    def rend(self):
        """rend(self) -> const_reverse_iterator"""
        return _almath.vectorPosition6D_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _almath.vectorPosition6D_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _almath.vectorPosition6D_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> vectorPosition6D
        __init__(self, vectorPosition6D arg0) -> vectorPosition6D
        __init__(self, size_type size) -> vectorPosition6D
        __init__(self, size_type size, value_type value) -> vectorPosition6D
        """
        this = _almath.new_vectorPosition6D(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _almath.vectorPosition6D_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _almath.vectorPosition6D_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _almath.vectorPosition6D_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _almath.vectorPosition6D_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _almath.vectorPosition6D_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _almath.vectorPosition6D_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _almath.vectorPosition6D_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _almath.vectorPosition6D_capacity(self)

    def __repr__(self):
        """__repr__(self) -> string"""
        return _almath.vectorPosition6D___repr__(self)

    __swig_destroy__ = _almath.delete_vectorPosition6D
    __del__ = lambda self : None;
vectorPosition6D_swigregister = _almath.vectorPosition6D_swigregister
vectorPosition6D_swigregister(vectorPosition6D)

class Pose2D(_object):
    """Proxy of C++ AL::Math::Pose2D class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Pose2D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Pose2D, name)
    __swig_setmethods__["x"] = _almath.Pose2D_x_set
    __swig_getmethods__["x"] = _almath.Pose2D_x_get
    if _newclass:x = _swig_property(_almath.Pose2D_x_get, _almath.Pose2D_x_set)
    __swig_setmethods__["y"] = _almath.Pose2D_y_set
    __swig_getmethods__["y"] = _almath.Pose2D_y_get
    if _newclass:y = _swig_property(_almath.Pose2D_y_get, _almath.Pose2D_y_set)
    __swig_setmethods__["theta"] = _almath.Pose2D_theta_set
    __swig_getmethods__["theta"] = _almath.Pose2D_theta_get
    if _newclass:theta = _swig_property(_almath.Pose2D_theta_get, _almath.Pose2D_theta_set)
    def __init__(self, *args): 
        """
        __init__(self) -> Pose2D
        __init__(self, float pInit) -> Pose2D
        __init__(self, float pX, float pY, float pTheta) -> Pose2D
        __init__(self, vectorFloat pFloats) -> Pose2D
        """
        this = _almath.new_Pose2D(*args)
        try: self.this.append(this)
        except: self.this = this
    def __add__(self, *args):
        """__add__(self, Pose2D pPos2) -> Pose2D"""
        return _almath.Pose2D___add__(self, *args)

    def __sub__(self, *args):
        """__sub__(self, Pose2D pPos2) -> Pose2D"""
        return _almath.Pose2D___sub__(self, *args)

    def __pos__(self):
        """__pos__(self) -> Pose2D"""
        return _almath.Pose2D___pos__(self)

    def __neg__(self):
        """__neg__(self) -> Pose2D"""
        return _almath.Pose2D___neg__(self)

    def __iadd__(self, *args):
        """__iadd__(self, Pose2D pPos2) -> Pose2D"""
        return _almath.Pose2D___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(self, Pose2D pPos2) -> Pose2D"""
        return _almath.Pose2D___isub__(self, *args)

    def __eq__(self, *args):
        """__eq__(self, Pose2D pPos2) -> bool"""
        return _almath.Pose2D___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, Pose2D pPos2) -> bool"""
        return _almath.Pose2D___ne__(self, *args)

    def __mul__(self, *args):
        """
        __mul__(self, Pose2D pPos2) -> Pose2D
        __mul__(self, float pVal) -> Pose2D
        """
        return _almath.Pose2D___mul__(self, *args)

    def __div__(self, *args):
        """__div__(self, float pVal) -> Pose2D"""
        return _almath.Pose2D___div__(self, *args)

    def __imul__(self, *args):
        """
        __imul__(self, Pose2D pPos2) -> Pose2D
        __imul__(self, float pVal) -> Pose2D
        """
        return _almath.Pose2D___imul__(self, *args)

    def __idiv__(self, *args):
        """__idiv__(self, float pVal) -> Pose2D"""
        return _almath.Pose2D___idiv__(self, *args)

    def distanceSquared(self, *args):
        """distanceSquared(self, Pose2D pPos2) -> float"""
        return _almath.Pose2D_distanceSquared(self, *args)

    def distance(self, *args):
        """distance(self, Pose2D pPos2) -> float"""
        return _almath.Pose2D_distance(self, *args)

    def inverse(self):
        """inverse(self) -> Pose2D"""
        return _almath.Pose2D_inverse(self)

    def isNear(self, *args):
        """
        isNear(self, Pose2D pPos2, float pEpsilon = 0.0001) -> bool
        isNear(self, Pose2D pPos2) -> bool
        """
        return _almath.Pose2D_isNear(self, *args)

    def toVector(self):
        """toVector(self) -> vectorFloat"""
        return _almath.Pose2D_toVector(self)

    def __repr__(self):
        """__repr__(self) -> char"""
        return _almath.Pose2D___repr__(self)

    def __rmul__(self, *args):
        """__rmul__(self, float lhs) -> Pose2D"""
        return _almath.Pose2D___rmul__(self, *args)

    __swig_destroy__ = _almath.delete_Pose2D
    __del__ = lambda self : None;
Pose2D_swigregister = _almath.Pose2D_swigregister
Pose2D_swigregister(Pose2D)
cvar = _almath.cvar
AXIS_MASK_X = cvar.AXIS_MASK_X
AXIS_MASK_Y = cvar.AXIS_MASK_Y
AXIS_MASK_XY = cvar.AXIS_MASK_XY
AXIS_MASK_Z = cvar.AXIS_MASK_Z
AXIS_MASK_WX = cvar.AXIS_MASK_WX
AXIS_MASK_WY = cvar.AXIS_MASK_WY
AXIS_MASK_WZ = cvar.AXIS_MASK_WZ
AXIS_MASK_WYWZ = cvar.AXIS_MASK_WYWZ
AXIS_MASK_ALL = cvar.AXIS_MASK_ALL
AXIS_MASK_VEL = cvar.AXIS_MASK_VEL
AXIS_MASK_ROT = cvar.AXIS_MASK_ROT
AXIS_MASK_NONE = cvar.AXIS_MASK_NONE

class Position2D(_object):
    """Proxy of C++ AL::Math::Position2D class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Position2D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Position2D, name)
    __swig_setmethods__["x"] = _almath.Position2D_x_set
    __swig_getmethods__["x"] = _almath.Position2D_x_get
    if _newclass:x = _swig_property(_almath.Position2D_x_get, _almath.Position2D_x_set)
    __swig_setmethods__["y"] = _almath.Position2D_y_set
    __swig_getmethods__["y"] = _almath.Position2D_y_get
    if _newclass:y = _swig_property(_almath.Position2D_y_get, _almath.Position2D_y_set)
    def __init__(self, *args): 
        """
        __init__(self) -> Position2D
        __init__(self, float pInit) -> Position2D
        __init__(self, float pX, float pY) -> Position2D
        __init__(self, vectorFloat pFloats) -> Position2D
        """
        this = _almath.new_Position2D(*args)
        try: self.this.append(this)
        except: self.this = this
    def __add__(self, *args):
        """__add__(self, Position2D pPos2) -> Position2D"""
        return _almath.Position2D___add__(self, *args)

    def __sub__(self, *args):
        """__sub__(self, Position2D pPos2) -> Position2D"""
        return _almath.Position2D___sub__(self, *args)

    def __pos__(self):
        """__pos__(self) -> Position2D"""
        return _almath.Position2D___pos__(self)

    def __neg__(self):
        """__neg__(self) -> Position2D"""
        return _almath.Position2D___neg__(self)

    def __iadd__(self, *args):
        """__iadd__(self, Position2D pPos2) -> Position2D"""
        return _almath.Position2D___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(self, Position2D pPos2) -> Position2D"""
        return _almath.Position2D___isub__(self, *args)

    def __eq__(self, *args):
        """__eq__(self, Position2D pPos2) -> bool"""
        return _almath.Position2D___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, Position2D pPos2) -> bool"""
        return _almath.Position2D___ne__(self, *args)

    def __mul__(self, *args):
        """__mul__(self, float pVal) -> Position2D"""
        return _almath.Position2D___mul__(self, *args)

    def __div__(self, *args):
        """__div__(self, float pVal) -> Position2D"""
        return _almath.Position2D___div__(self, *args)

    def __imul__(self, *args):
        """__imul__(self, float pVal) -> Position2D"""
        return _almath.Position2D___imul__(self, *args)

    def __idiv__(self, *args):
        """__idiv__(self, float pVal) -> Position2D"""
        return _almath.Position2D___idiv__(self, *args)

    def distanceSquared(self, *args):
        """distanceSquared(self, Position2D pPos2) -> float"""
        return _almath.Position2D_distanceSquared(self, *args)

    def distance(self, *args):
        """distance(self, Position2D pPos2) -> float"""
        return _almath.Position2D_distance(self, *args)

    def isNear(self, *args):
        """
        isNear(self, Position2D pPos2, float pEpsilon = 0.0001) -> bool
        isNear(self, Position2D pPos2) -> bool
        """
        return _almath.Position2D_isNear(self, *args)

    def norm(self):
        """norm(self) -> float"""
        return _almath.Position2D_norm(self)

    def normalize(self):
        """normalize(self) -> Position2D"""
        return _almath.Position2D_normalize(self)

    def crossProduct(self, *args):
        """crossProduct(self, Position2D pPos2) -> float"""
        return _almath.Position2D_crossProduct(self, *args)

    def toVector(self):
        """toVector(self) -> vectorFloat"""
        return _almath.Position2D_toVector(self)

    def __repr__(self):
        """__repr__(self) -> char"""
        return _almath.Position2D___repr__(self)

    def __rmul__(self, *args):
        """__rmul__(self, float lhs) -> Position2D"""
        return _almath.Position2D___rmul__(self, *args)

    __swig_destroy__ = _almath.delete_Position2D
    __del__ = lambda self : None;
Position2D_swigregister = _almath.Position2D_swigregister
Position2D_swigregister(Position2D)

def pose2DInverse(*args):
  """
    pose2DInverse(Pose2D pPos) -> Pose2D
    pose2DInverse(Pose2D pPos, Pose2D pRes)
    """
  return _almath.pose2DInverse(*args)

class Position3D(_object):
    """Proxy of C++ AL::Math::Position3D class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Position3D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Position3D, name)
    __swig_setmethods__["x"] = _almath.Position3D_x_set
    __swig_getmethods__["x"] = _almath.Position3D_x_get
    if _newclass:x = _swig_property(_almath.Position3D_x_get, _almath.Position3D_x_set)
    __swig_setmethods__["y"] = _almath.Position3D_y_set
    __swig_getmethods__["y"] = _almath.Position3D_y_get
    if _newclass:y = _swig_property(_almath.Position3D_y_get, _almath.Position3D_y_set)
    __swig_setmethods__["z"] = _almath.Position3D_z_set
    __swig_getmethods__["z"] = _almath.Position3D_z_get
    if _newclass:z = _swig_property(_almath.Position3D_z_get, _almath.Position3D_z_set)
    def __init__(self, *args): 
        """
        __init__(self) -> Position3D
        __init__(self, float pInit) -> Position3D
        __init__(self, float pX, float pY, float pZ) -> Position3D
        __init__(self, vectorFloat pFloats) -> Position3D
        """
        this = _almath.new_Position3D(*args)
        try: self.this.append(this)
        except: self.this = this
    def __add__(self, *args):
        """__add__(self, Position3D pPos2) -> Position3D"""
        return _almath.Position3D___add__(self, *args)

    def __sub__(self, *args):
        """__sub__(self, Position3D pPos2) -> Position3D"""
        return _almath.Position3D___sub__(self, *args)

    def __pos__(self):
        """__pos__(self) -> Position3D"""
        return _almath.Position3D___pos__(self)

    def __neg__(self):
        """__neg__(self) -> Position3D"""
        return _almath.Position3D___neg__(self)

    def __iadd__(self, *args):
        """__iadd__(self, Position3D pPos2) -> Position3D"""
        return _almath.Position3D___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(self, Position3D pPos2) -> Position3D"""
        return _almath.Position3D___isub__(self, *args)

    def __eq__(self, *args):
        """__eq__(self, Position3D pPos2) -> bool"""
        return _almath.Position3D___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, Position3D pPos2) -> bool"""
        return _almath.Position3D___ne__(self, *args)

    def __mul__(self, *args):
        """__mul__(self, float pVal) -> Position3D"""
        return _almath.Position3D___mul__(self, *args)

    def __div__(self, *args):
        """__div__(self, float pVal) -> Position3D"""
        return _almath.Position3D___div__(self, *args)

    def __imul__(self, *args):
        """__imul__(self, float pVal) -> Position3D"""
        return _almath.Position3D___imul__(self, *args)

    def __idiv__(self, *args):
        """__idiv__(self, float pVal) -> Position3D"""
        return _almath.Position3D___idiv__(self, *args)

    def distanceSquared(self, *args):
        """distanceSquared(self, Position3D pPos2) -> float"""
        return _almath.Position3D_distanceSquared(self, *args)

    def distance(self, *args):
        """distance(self, Position3D pPos2) -> float"""
        return _almath.Position3D_distance(self, *args)

    def isNear(self, *args):
        """
        isNear(self, Position3D pPos2, float pEpsilon = 0.0001) -> bool
        isNear(self, Position3D pPos2) -> bool
        """
        return _almath.Position3D_isNear(self, *args)

    def norm(self):
        """norm(self) -> float"""
        return _almath.Position3D_norm(self)

    def normalize(self):
        """normalize(self) -> Position3D"""
        return _almath.Position3D_normalize(self)

    def dotProduct(self, *args):
        """dotProduct(self, Position3D pPos2) -> float"""
        return _almath.Position3D_dotProduct(self, *args)

    def crossProduct(self, *args):
        """crossProduct(self, Position3D pPos2) -> Position3D"""
        return _almath.Position3D_crossProduct(self, *args)

    def toVector(self):
        """toVector(self) -> vectorFloat"""
        return _almath.Position3D_toVector(self)

    def __repr__(self):
        """__repr__(self) -> char"""
        return _almath.Position3D___repr__(self)

    def __rmul__(self, *args):
        """__rmul__(self, float lhs) -> Position3D"""
        return _almath.Position3D___rmul__(self, *args)

    __swig_destroy__ = _almath.delete_Position3D
    __del__ = lambda self : None;
Position3D_swigregister = _almath.Position3D_swigregister
Position3D_swigregister(Position3D)


def __div__(*args):
  """__div__(float pM, Position3D pPos1) -> Position3D"""
  return _almath.__div__(*args)

def dotProduct(*args):
  """dotProduct(Position3D pPos1, Position3D pPos2) -> float"""
  return _almath.dotProduct(*args)
class Position6D(_object):
    """Proxy of C++ AL::Math::Position6D class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Position6D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Position6D, name)
    __swig_setmethods__["x"] = _almath.Position6D_x_set
    __swig_getmethods__["x"] = _almath.Position6D_x_get
    if _newclass:x = _swig_property(_almath.Position6D_x_get, _almath.Position6D_x_set)
    __swig_setmethods__["y"] = _almath.Position6D_y_set
    __swig_getmethods__["y"] = _almath.Position6D_y_get
    if _newclass:y = _swig_property(_almath.Position6D_y_get, _almath.Position6D_y_set)
    __swig_setmethods__["z"] = _almath.Position6D_z_set
    __swig_getmethods__["z"] = _almath.Position6D_z_get
    if _newclass:z = _swig_property(_almath.Position6D_z_get, _almath.Position6D_z_set)
    __swig_setmethods__["wx"] = _almath.Position6D_wx_set
    __swig_getmethods__["wx"] = _almath.Position6D_wx_get
    if _newclass:wx = _swig_property(_almath.Position6D_wx_get, _almath.Position6D_wx_set)
    __swig_setmethods__["wy"] = _almath.Position6D_wy_set
    __swig_getmethods__["wy"] = _almath.Position6D_wy_get
    if _newclass:wy = _swig_property(_almath.Position6D_wy_get, _almath.Position6D_wy_set)
    __swig_setmethods__["wz"] = _almath.Position6D_wz_set
    __swig_getmethods__["wz"] = _almath.Position6D_wz_get
    if _newclass:wz = _swig_property(_almath.Position6D_wz_get, _almath.Position6D_wz_set)
    def __init__(self, *args): 
        """
        __init__(self) -> Position6D
        __init__(self, float pInit) -> Position6D
        __init__(self, float pX, float pY, float pZ, float pWx, float pWy, 
            float pWz) -> Position6D
        __init__(self, vectorFloat pFloats) -> Position6D
        """
        this = _almath.new_Position6D(*args)
        try: self.this.append(this)
        except: self.this = this
    def __add__(self, *args):
        """__add__(self, Position6D pPos2) -> Position6D"""
        return _almath.Position6D___add__(self, *args)

    def __sub__(self, *args):
        """__sub__(self, Position6D pPos2) -> Position6D"""
        return _almath.Position6D___sub__(self, *args)

    def __pos__(self):
        """__pos__(self) -> Position6D"""
        return _almath.Position6D___pos__(self)

    def __neg__(self):
        """__neg__(self) -> Position6D"""
        return _almath.Position6D___neg__(self)

    def __iadd__(self, *args):
        """__iadd__(self, Position6D pPos2) -> Position6D"""
        return _almath.Position6D___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(self, Position6D pPos2) -> Position6D"""
        return _almath.Position6D___isub__(self, *args)

    def __eq__(self, *args):
        """__eq__(self, Position6D pPos2) -> bool"""
        return _almath.Position6D___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, Position6D pPos2) -> bool"""
        return _almath.Position6D___ne__(self, *args)

    def __mul__(self, *args):
        """__mul__(self, float pVal) -> Position6D"""
        return _almath.Position6D___mul__(self, *args)

    def __div__(self, *args):
        """__div__(self, float pVal) -> Position6D"""
        return _almath.Position6D___div__(self, *args)

    def __imul__(self, *args):
        """__imul__(self, float pVal) -> Position6D"""
        return _almath.Position6D___imul__(self, *args)

    def __idiv__(self, *args):
        """__idiv__(self, float pVal) -> Position6D"""
        return _almath.Position6D___idiv__(self, *args)

    def isNear(self, *args):
        """
        isNear(self, Position6D pPos2, float pEpsilon = 0.0001) -> bool
        isNear(self, Position6D pPos2) -> bool
        """
        return _almath.Position6D_isNear(self, *args)

    def distanceSquared(self, *args):
        """distanceSquared(self, Position6D pPos2) -> float"""
        return _almath.Position6D_distanceSquared(self, *args)

    def distance(self, *args):
        """distance(self, Position6D pPos2) -> float"""
        return _almath.Position6D_distance(self, *args)

    def norm(self):
        """norm(self) -> float"""
        return _almath.Position6D_norm(self)

    def toVector(self):
        """toVector(self) -> vectorFloat"""
        return _almath.Position6D_toVector(self)

    def __repr__(self):
        """__repr__(self) -> char"""
        return _almath.Position6D___repr__(self)

    def __rmul__(self, *args):
        """__rmul__(self, float lhs) -> Position6D"""
        return _almath.Position6D___rmul__(self, *args)

    __swig_destroy__ = _almath.delete_Position6D
    __del__ = lambda self : None;
Position6D_swigregister = _almath.Position6D_swigregister
Position6D_swigregister(Position6D)

def crossProduct(*args):
  """
    crossProduct(Position2D pPos1, Position2D pPos2) -> float
    crossProduct(Position2D pPos1, Position2D pPos2, float pRes)
    crossProduct(Position3D pPos1, Position3D pPos2) -> Position3D
    crossProduct(Position3D pPos1, Position3D pPos2, Position3D pRes)
    """
  return _almath.crossProduct(*args)

class PositionAndVelocity(_object):
    """Proxy of C++ AL::Math::PositionAndVelocity class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PositionAndVelocity, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PositionAndVelocity, name)
    __swig_setmethods__["q"] = _almath.PositionAndVelocity_q_set
    __swig_getmethods__["q"] = _almath.PositionAndVelocity_q_get
    if _newclass:q = _swig_property(_almath.PositionAndVelocity_q_get, _almath.PositionAndVelocity_q_set)
    __swig_setmethods__["dq"] = _almath.PositionAndVelocity_dq_set
    __swig_getmethods__["dq"] = _almath.PositionAndVelocity_dq_get
    if _newclass:dq = _swig_property(_almath.PositionAndVelocity_dq_get, _almath.PositionAndVelocity_dq_set)
    def __init__(self, pq = 0.0, pdq = 0.0): 
        """
        __init__(self, float pq = 0.0, float pdq = 0.0) -> PositionAndVelocity
        __init__(self, float pq = 0.0) -> PositionAndVelocity
        __init__(self) -> PositionAndVelocity
        """
        this = _almath.new_PositionAndVelocity(pq, pdq)
        try: self.this.append(this)
        except: self.this = this
    def isNear(self, *args):
        """
        isNear(self, PositionAndVelocity pDat2, float pEpsilon = 0.0001) -> bool
        isNear(self, PositionAndVelocity pDat2) -> bool
        """
        return _almath.PositionAndVelocity_isNear(self, *args)

    def __repr__(self):
        """__repr__(self) -> char"""
        return _almath.PositionAndVelocity___repr__(self)

    __swig_destroy__ = _almath.delete_PositionAndVelocity
    __del__ = lambda self : None;
PositionAndVelocity_swigregister = _almath.PositionAndVelocity_swigregister
PositionAndVelocity_swigregister(PositionAndVelocity)

def distanceSquared(*args):
  """
    distanceSquared(Pose2D pPos1, Pose2D pPos2) -> float
    distanceSquared(Position2D pPos1, Position2D pPos2) -> float
    distanceSquared(Position3D pPos1, Position3D pPos2) -> float
    distanceSquared(Position6D pPos1, Position6D pPos2) -> float
    """
  return _almath.distanceSquared(*args)

def distance(*args):
  """
    distance(Pose2D pPos1, Pose2D pPos2) -> float
    distance(Position2D pPos1, Position2D pPos2) -> float
    distance(Position3D pPos1, Position3D pPos2) -> float
    distance(Position6D pPos1, Position6D pPos2) -> float
    """
  return _almath.distance(*args)

class Quaternion(_object):
    """Proxy of C++ AL::Math::Quaternion class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Quaternion, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Quaternion, name)
    __swig_setmethods__["w"] = _almath.Quaternion_w_set
    __swig_getmethods__["w"] = _almath.Quaternion_w_get
    if _newclass:w = _swig_property(_almath.Quaternion_w_get, _almath.Quaternion_w_set)
    __swig_setmethods__["x"] = _almath.Quaternion_x_set
    __swig_getmethods__["x"] = _almath.Quaternion_x_get
    if _newclass:x = _swig_property(_almath.Quaternion_x_get, _almath.Quaternion_x_set)
    __swig_setmethods__["y"] = _almath.Quaternion_y_set
    __swig_getmethods__["y"] = _almath.Quaternion_y_get
    if _newclass:y = _swig_property(_almath.Quaternion_y_get, _almath.Quaternion_y_set)
    __swig_setmethods__["z"] = _almath.Quaternion_z_set
    __swig_getmethods__["z"] = _almath.Quaternion_z_get
    if _newclass:z = _swig_property(_almath.Quaternion_z_get, _almath.Quaternion_z_set)
    def __init__(self, *args): 
        """
        __init__(self) -> Quaternion
        __init__(self, float pW, float pX, float pY, float pZ) -> Quaternion
        __init__(self, vectorFloat pFloats) -> Quaternion
        """
        this = _almath.new_Quaternion(*args)
        try: self.this.append(this)
        except: self.this = this
    def __mul__(self, *args):
        """__mul__(self, Quaternion pQua2) -> Quaternion"""
        return _almath.Quaternion___mul__(self, *args)

    def __eq__(self, *args):
        """__eq__(self, Quaternion pQua2) -> bool"""
        return _almath.Quaternion___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, Quaternion pQua2) -> bool"""
        return _almath.Quaternion___ne__(self, *args)

    def __imul__(self, *args):
        """
        __imul__(self, Quaternion pQu2) -> Quaternion
        __imul__(self, float pVal) -> Quaternion
        """
        return _almath.Quaternion___imul__(self, *args)

    def __idiv__(self, *args):
        """__idiv__(self, float pVal) -> Quaternion"""
        return _almath.Quaternion___idiv__(self, *args)

    def isNear(self, *args):
        """
        isNear(self, Quaternion pQua2, float pEpsilon = 0.0001) -> bool
        isNear(self, Quaternion pQua2) -> bool
        """
        return _almath.Quaternion_isNear(self, *args)

    def norm(self):
        """norm(self) -> float"""
        return _almath.Quaternion_norm(self)

    def normalize(self):
        """normalize(self) -> Quaternion"""
        return _almath.Quaternion_normalize(self)

    def inverse(self):
        """inverse(self) -> Quaternion"""
        return _almath.Quaternion_inverse(self)

    def fromAngleAndAxisRotation(*args):
        """fromAngleAndAxisRotation(float pAngle, float pAxisX, float pAxisY, float pAxisZ) -> Quaternion"""
        return _almath.Quaternion_fromAngleAndAxisRotation(*args)

    if _newclass:fromAngleAndAxisRotation = staticmethod(fromAngleAndAxisRotation)
    __swig_getmethods__["fromAngleAndAxisRotation"] = lambda x: fromAngleAndAxisRotation
    def toVector(self):
        """toVector(self) -> vectorFloat"""
        return _almath.Quaternion_toVector(self)

    def __repr__(self):
        """__repr__(self) -> char"""
        return _almath.Quaternion___repr__(self)

    __swig_destroy__ = _almath.delete_Quaternion
    __del__ = lambda self : None;
Quaternion_swigregister = _almath.Quaternion_swigregister
Quaternion_swigregister(Quaternion)

def Quaternion_fromAngleAndAxisRotation(*args):
  """Quaternion_fromAngleAndAxisRotation(float pAngle, float pAxisX, float pAxisY, float pAxisZ) -> Quaternion"""
  return _almath.Quaternion_fromAngleAndAxisRotation(*args)


def quaternionFromAngleAndAxisRotation(*args):
  """quaternionFromAngleAndAxisRotation(float pAngle, float pAxisX, float pAxisY, float pAxisZ) -> Quaternion"""
  return _almath.quaternionFromAngleAndAxisRotation(*args)

def angleAndAxisRotationFromQuaternion(*args):
  """
    angleAndAxisRotationFromQuaternion(Quaternion pQuaternion, float pAngle, float pAxisX, 
        float pAxisY, float pAxisZ)
    """
  return _almath.angleAndAxisRotationFromQuaternion(*args)
class Rotation(_object):
    """Proxy of C++ AL::Math::Rotation class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Rotation, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Rotation, name)
    __swig_setmethods__["r1_c1"] = _almath.Rotation_r1_c1_set
    __swig_getmethods__["r1_c1"] = _almath.Rotation_r1_c1_get
    if _newclass:r1_c1 = _swig_property(_almath.Rotation_r1_c1_get, _almath.Rotation_r1_c1_set)
    __swig_setmethods__["r1_c2"] = _almath.Rotation_r1_c2_set
    __swig_getmethods__["r1_c2"] = _almath.Rotation_r1_c2_get
    if _newclass:r1_c2 = _swig_property(_almath.Rotation_r1_c2_get, _almath.Rotation_r1_c2_set)
    __swig_setmethods__["r1_c3"] = _almath.Rotation_r1_c3_set
    __swig_getmethods__["r1_c3"] = _almath.Rotation_r1_c3_get
    if _newclass:r1_c3 = _swig_property(_almath.Rotation_r1_c3_get, _almath.Rotation_r1_c3_set)
    __swig_setmethods__["r2_c1"] = _almath.Rotation_r2_c1_set
    __swig_getmethods__["r2_c1"] = _almath.Rotation_r2_c1_get
    if _newclass:r2_c1 = _swig_property(_almath.Rotation_r2_c1_get, _almath.Rotation_r2_c1_set)
    __swig_setmethods__["r2_c2"] = _almath.Rotation_r2_c2_set
    __swig_getmethods__["r2_c2"] = _almath.Rotation_r2_c2_get
    if _newclass:r2_c2 = _swig_property(_almath.Rotation_r2_c2_get, _almath.Rotation_r2_c2_set)
    __swig_setmethods__["r2_c3"] = _almath.Rotation_r2_c3_set
    __swig_getmethods__["r2_c3"] = _almath.Rotation_r2_c3_get
    if _newclass:r2_c3 = _swig_property(_almath.Rotation_r2_c3_get, _almath.Rotation_r2_c3_set)
    __swig_setmethods__["r3_c1"] = _almath.Rotation_r3_c1_set
    __swig_getmethods__["r3_c1"] = _almath.Rotation_r3_c1_get
    if _newclass:r3_c1 = _swig_property(_almath.Rotation_r3_c1_get, _almath.Rotation_r3_c1_set)
    __swig_setmethods__["r3_c2"] = _almath.Rotation_r3_c2_set
    __swig_getmethods__["r3_c2"] = _almath.Rotation_r3_c2_get
    if _newclass:r3_c2 = _swig_property(_almath.Rotation_r3_c2_get, _almath.Rotation_r3_c2_set)
    __swig_setmethods__["r3_c3"] = _almath.Rotation_r3_c3_set
    __swig_getmethods__["r3_c3"] = _almath.Rotation_r3_c3_get
    if _newclass:r3_c3 = _swig_property(_almath.Rotation_r3_c3_get, _almath.Rotation_r3_c3_set)
    def __init__(self, *args): 
        """
        __init__(self) -> Rotation
        __init__(self, vectorFloat pFloats) -> Rotation
        """
        this = _almath.new_Rotation(*args)
        try: self.this.append(this)
        except: self.this = this
    def __imul__(self, *args):
        """__imul__(self, Rotation pRot2) -> Rotation"""
        return _almath.Rotation___imul__(self, *args)

    def __eq__(self, *args):
        """__eq__(self, Rotation pRot2) -> bool"""
        return _almath.Rotation___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, Rotation pRot2) -> bool"""
        return _almath.Rotation___ne__(self, *args)

    def isNear(self, *args):
        """
        isNear(self, Rotation pRot2, float pEpsilon = 0.0001) -> bool
        isNear(self, Rotation pRot2) -> bool
        """
        return _almath.Rotation_isNear(self, *args)

    def transpose(self):
        """transpose(self) -> Rotation"""
        return _almath.Rotation_transpose(self)

    def determinant(self):
        """determinant(self) -> float"""
        return _almath.Rotation_determinant(self)

    def fromQuaternion(*args):
        """fromQuaternion(float pA, float pB, float pC, float pD) -> Rotation"""
        return _almath.Rotation_fromQuaternion(*args)

    if _newclass:fromQuaternion = staticmethod(fromQuaternion)
    __swig_getmethods__["fromQuaternion"] = lambda x: fromQuaternion
    def fromAngleDirection(*args):
        """fromAngleDirection(float pAngle, float pX, float pY, float pZ) -> Rotation"""
        return _almath.Rotation_fromAngleDirection(*args)

    if _newclass:fromAngleDirection = staticmethod(fromAngleDirection)
    __swig_getmethods__["fromAngleDirection"] = lambda x: fromAngleDirection
    def fromRotX(*args):
        """fromRotX(float pRotX) -> Rotation"""
        return _almath.Rotation_fromRotX(*args)

    if _newclass:fromRotX = staticmethod(fromRotX)
    __swig_getmethods__["fromRotX"] = lambda x: fromRotX
    def fromRotY(*args):
        """fromRotY(float pRotY) -> Rotation"""
        return _almath.Rotation_fromRotY(*args)

    if _newclass:fromRotY = staticmethod(fromRotY)
    __swig_getmethods__["fromRotY"] = lambda x: fromRotY
    def fromRotZ(*args):
        """fromRotZ(float pRotZ) -> Rotation"""
        return _almath.Rotation_fromRotZ(*args)

    if _newclass:fromRotZ = staticmethod(fromRotZ)
    __swig_getmethods__["fromRotZ"] = lambda x: fromRotZ
    def from3DRotation(*args):
        """from3DRotation(float pWX, float pWY, float pWZ) -> Rotation"""
        return _almath.Rotation_from3DRotation(*args)

    if _newclass:from3DRotation = staticmethod(from3DRotation)
    __swig_getmethods__["from3DRotation"] = lambda x: from3DRotation
    def toVector(self):
        """toVector(self) -> vectorFloat"""
        return _almath.Rotation_toVector(self)

    def __str__(self):
        """__str__(self) -> char"""
        return _almath.Rotation___str__(self)

    def __repr__(self):
        """__repr__(self) -> char"""
        return _almath.Rotation___repr__(self)

    def __mul__(self, *args):
        """
        __mul__(self, Rotation pRot2) -> Rotation
        __mul__(self, Position3D rhs) -> Position3D
        """
        return _almath.Rotation___mul__(self, *args)

    __swig_destroy__ = _almath.delete_Rotation
    __del__ = lambda self : None;
Rotation_swigregister = _almath.Rotation_swigregister
Rotation_swigregister(Rotation)

def quaternionInverse(*args):
  """
    quaternionInverse(Quaternion pQua, Quaternion pQuaOut)
    quaternionInverse(Quaternion pQua) -> Quaternion
    """
  return _almath.quaternionInverse(*args)

def Rotation_fromQuaternion(*args):
  """Rotation_fromQuaternion(float pA, float pB, float pC, float pD) -> Rotation"""
  return _almath.Rotation_fromQuaternion(*args)

def Rotation_fromAngleDirection(*args):
  """Rotation_fromAngleDirection(float pAngle, float pX, float pY, float pZ) -> Rotation"""
  return _almath.Rotation_fromAngleDirection(*args)

def Rotation_fromRotX(*args):
  """Rotation_fromRotX(float pRotX) -> Rotation"""
  return _almath.Rotation_fromRotX(*args)

def Rotation_fromRotY(*args):
  """Rotation_fromRotY(float pRotY) -> Rotation"""
  return _almath.Rotation_fromRotY(*args)

def Rotation_fromRotZ(*args):
  """Rotation_fromRotZ(float pRotZ) -> Rotation"""
  return _almath.Rotation_fromRotZ(*args)

def Rotation_from3DRotation(*args):
  """Rotation_from3DRotation(float pWX, float pWY, float pWZ) -> Rotation"""
  return _almath.Rotation_from3DRotation(*args)


def transpose(*args):
  """transpose(Rotation pRot) -> Rotation"""
  return _almath.transpose(*args)

def rotationFromQuaternion(*args):
  """rotationFromQuaternion(float pA, float pB, float pC, float pD) -> Rotation"""
  return _almath.rotationFromQuaternion(*args)

def applyRotation(*args):
  """applyRotation(Rotation pRot, float pX, float pY, float pZ)"""
  return _almath.applyRotation(*args)

def rotationFromRotX(*args):
  """rotationFromRotX(float pRotX) -> Rotation"""
  return _almath.rotationFromRotX(*args)

def rotationFromRotY(*args):
  """rotationFromRotY(float pRotY) -> Rotation"""
  return _almath.rotationFromRotY(*args)

def rotationFromRotZ(*args):
  """rotationFromRotZ(float pRotZ) -> Rotation"""
  return _almath.rotationFromRotZ(*args)

def rotationFrom3DRotation(*args):
  """rotationFrom3DRotation(float pWX, float pWY, float pWZ) -> Rotation"""
  return _almath.rotationFrom3DRotation(*args)
class Rotation3D(_object):
    """Proxy of C++ AL::Math::Rotation3D class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Rotation3D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Rotation3D, name)
    __swig_setmethods__["wx"] = _almath.Rotation3D_wx_set
    __swig_getmethods__["wx"] = _almath.Rotation3D_wx_get
    if _newclass:wx = _swig_property(_almath.Rotation3D_wx_get, _almath.Rotation3D_wx_set)
    __swig_setmethods__["wy"] = _almath.Rotation3D_wy_set
    __swig_getmethods__["wy"] = _almath.Rotation3D_wy_get
    if _newclass:wy = _swig_property(_almath.Rotation3D_wy_get, _almath.Rotation3D_wy_set)
    __swig_setmethods__["wz"] = _almath.Rotation3D_wz_set
    __swig_getmethods__["wz"] = _almath.Rotation3D_wz_get
    if _newclass:wz = _swig_property(_almath.Rotation3D_wz_get, _almath.Rotation3D_wz_set)
    def __init__(self, *args): 
        """
        __init__(self) -> Rotation3D
        __init__(self, float pInit) -> Rotation3D
        __init__(self, float pWx, float pWy, float pWz) -> Rotation3D
        __init__(self, vectorFloat pFloats) -> Rotation3D
        """
        this = _almath.new_Rotation3D(*args)
        try: self.this.append(this)
        except: self.this = this
    def __add__(self, *args):
        """__add__(self, Rotation3D pRot2) -> Rotation3D"""
        return _almath.Rotation3D___add__(self, *args)

    def __sub__(self, *args):
        """__sub__(self, Rotation3D pRot2) -> Rotation3D"""
        return _almath.Rotation3D___sub__(self, *args)

    def __iadd__(self, *args):
        """__iadd__(self, Rotation3D pRot2) -> Rotation3D"""
        return _almath.Rotation3D___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(self, Rotation3D pRot2) -> Rotation3D"""
        return _almath.Rotation3D___isub__(self, *args)

    def __eq__(self, *args):
        """__eq__(self, Rotation3D pRot2) -> bool"""
        return _almath.Rotation3D___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, Rotation3D pRot2) -> bool"""
        return _almath.Rotation3D___ne__(self, *args)

    def __mul__(self, *args):
        """__mul__(self, float pVal) -> Rotation3D"""
        return _almath.Rotation3D___mul__(self, *args)

    def __div__(self, *args):
        """__div__(self, float pVal) -> Rotation3D"""
        return _almath.Rotation3D___div__(self, *args)

    def __imul__(self, *args):
        """__imul__(self, float pVal) -> Rotation3D"""
        return _almath.Rotation3D___imul__(self, *args)

    def __idiv__(self, *args):
        """__idiv__(self, float pVal) -> Rotation3D"""
        return _almath.Rotation3D___idiv__(self, *args)

    def isNear(self, *args):
        """
        isNear(self, Rotation3D pRot2, float pEpsilon = 0.0001) -> bool
        isNear(self, Rotation3D pRot2) -> bool
        """
        return _almath.Rotation3D_isNear(self, *args)

    def norm(self):
        """norm(self) -> float"""
        return _almath.Rotation3D_norm(self)

    def toVector(self):
        """toVector(self) -> vectorFloat"""
        return _almath.Rotation3D_toVector(self)

    def __repr__(self):
        """__repr__(self) -> char"""
        return _almath.Rotation3D___repr__(self)

    __swig_destroy__ = _almath.delete_Rotation3D
    __del__ = lambda self : None;
Rotation3D_swigregister = _almath.Rotation3D_swigregister
Rotation3D_swigregister(Rotation3D)

class Transform(_object):
    """Proxy of C++ AL::Math::Transform class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Transform, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Transform, name)
    __swig_setmethods__["r1_c1"] = _almath.Transform_r1_c1_set
    __swig_getmethods__["r1_c1"] = _almath.Transform_r1_c1_get
    if _newclass:r1_c1 = _swig_property(_almath.Transform_r1_c1_get, _almath.Transform_r1_c1_set)
    __swig_setmethods__["r1_c2"] = _almath.Transform_r1_c2_set
    __swig_getmethods__["r1_c2"] = _almath.Transform_r1_c2_get
    if _newclass:r1_c2 = _swig_property(_almath.Transform_r1_c2_get, _almath.Transform_r1_c2_set)
    __swig_setmethods__["r1_c3"] = _almath.Transform_r1_c3_set
    __swig_getmethods__["r1_c3"] = _almath.Transform_r1_c3_get
    if _newclass:r1_c3 = _swig_property(_almath.Transform_r1_c3_get, _almath.Transform_r1_c3_set)
    __swig_setmethods__["r1_c4"] = _almath.Transform_r1_c4_set
    __swig_getmethods__["r1_c4"] = _almath.Transform_r1_c4_get
    if _newclass:r1_c4 = _swig_property(_almath.Transform_r1_c4_get, _almath.Transform_r1_c4_set)
    __swig_setmethods__["r2_c1"] = _almath.Transform_r2_c1_set
    __swig_getmethods__["r2_c1"] = _almath.Transform_r2_c1_get
    if _newclass:r2_c1 = _swig_property(_almath.Transform_r2_c1_get, _almath.Transform_r2_c1_set)
    __swig_setmethods__["r2_c2"] = _almath.Transform_r2_c2_set
    __swig_getmethods__["r2_c2"] = _almath.Transform_r2_c2_get
    if _newclass:r2_c2 = _swig_property(_almath.Transform_r2_c2_get, _almath.Transform_r2_c2_set)
    __swig_setmethods__["r2_c3"] = _almath.Transform_r2_c3_set
    __swig_getmethods__["r2_c3"] = _almath.Transform_r2_c3_get
    if _newclass:r2_c3 = _swig_property(_almath.Transform_r2_c3_get, _almath.Transform_r2_c3_set)
    __swig_setmethods__["r2_c4"] = _almath.Transform_r2_c4_set
    __swig_getmethods__["r2_c4"] = _almath.Transform_r2_c4_get
    if _newclass:r2_c4 = _swig_property(_almath.Transform_r2_c4_get, _almath.Transform_r2_c4_set)
    __swig_setmethods__["r3_c1"] = _almath.Transform_r3_c1_set
    __swig_getmethods__["r3_c1"] = _almath.Transform_r3_c1_get
    if _newclass:r3_c1 = _swig_property(_almath.Transform_r3_c1_get, _almath.Transform_r3_c1_set)
    __swig_setmethods__["r3_c2"] = _almath.Transform_r3_c2_set
    __swig_getmethods__["r3_c2"] = _almath.Transform_r3_c2_get
    if _newclass:r3_c2 = _swig_property(_almath.Transform_r3_c2_get, _almath.Transform_r3_c2_set)
    __swig_setmethods__["r3_c3"] = _almath.Transform_r3_c3_set
    __swig_getmethods__["r3_c3"] = _almath.Transform_r3_c3_get
    if _newclass:r3_c3 = _swig_property(_almath.Transform_r3_c3_get, _almath.Transform_r3_c3_set)
    __swig_setmethods__["r3_c4"] = _almath.Transform_r3_c4_set
    __swig_getmethods__["r3_c4"] = _almath.Transform_r3_c4_get
    if _newclass:r3_c4 = _swig_property(_almath.Transform_r3_c4_get, _almath.Transform_r3_c4_set)
    def __init__(self, *args): 
        """
        __init__(self) -> Transform
        __init__(self, vectorFloat pFloats) -> Transform
        __init__(self, float pPosX, float pPosY, float pPosZ) -> Transform
        """
        this = _almath.new_Transform(*args)
        try: self.this.append(this)
        except: self.this = this
    def __imul__(self, *args):
        """__imul__(self, Transform pT2) -> Transform"""
        return _almath.Transform___imul__(self, *args)

    def __eq__(self, *args):
        """__eq__(self, Transform pT2) -> bool"""
        return _almath.Transform___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, Transform pT2) -> bool"""
        return _almath.Transform___ne__(self, *args)

    def isNear(self, *args):
        """
        isNear(self, Transform pT2, float pEpsilon = 0.0001) -> bool
        isNear(self, Transform pT2) -> bool
        """
        return _almath.Transform_isNear(self, *args)

    def isTransform(self, pEpsilon = 0.0001):
        """
        isTransform(self, float pEpsilon = 0.0001) -> bool
        isTransform(self) -> bool
        """
        return _almath.Transform_isTransform(self, pEpsilon)

    def norm(self):
        """norm(self) -> float"""
        return _almath.Transform_norm(self)

    def determinant(self):
        """determinant(self) -> float"""
        return _almath.Transform_determinant(self)

    def inverse(self):
        """inverse(self) -> Transform"""
        return _almath.Transform_inverse(self)

    def fromRotX(*args):
        """fromRotX(float pRotX) -> Transform"""
        return _almath.Transform_fromRotX(*args)

    if _newclass:fromRotX = staticmethod(fromRotX)
    __swig_getmethods__["fromRotX"] = lambda x: fromRotX
    def fromRotY(*args):
        """fromRotY(float pRotY) -> Transform"""
        return _almath.Transform_fromRotY(*args)

    if _newclass:fromRotY = staticmethod(fromRotY)
    __swig_getmethods__["fromRotY"] = lambda x: fromRotY
    def fromRotZ(*args):
        """fromRotZ(float pRotZ) -> Transform"""
        return _almath.Transform_fromRotZ(*args)

    if _newclass:fromRotZ = staticmethod(fromRotZ)
    __swig_getmethods__["fromRotZ"] = lambda x: fromRotZ
    def from3DRotation(*args):
        """from3DRotation(float pWX, float pWY, float pWZ) -> Transform"""
        return _almath.Transform_from3DRotation(*args)

    if _newclass:from3DRotation = staticmethod(from3DRotation)
    __swig_getmethods__["from3DRotation"] = lambda x: from3DRotation
    def fromPosition(*args):
        """
        fromPosition(float pX, float pY, float pZ) -> Transform
        fromPosition(float pX, float pY, float pZ, float pWX, float pWY, 
            float pWZ) -> Transform
        """
        return _almath.Transform_fromPosition(*args)

    if _newclass:fromPosition = staticmethod(fromPosition)
    __swig_getmethods__["fromPosition"] = lambda x: fromPosition
    def diff(self, *args):
        """diff(self, Transform pT2) -> Transform"""
        return _almath.Transform_diff(self, *args)

    def distanceSquared(self, *args):
        """distanceSquared(self, Transform pT2) -> float"""
        return _almath.Transform_distanceSquared(self, *args)

    def distance(self, *args):
        """distance(self, Transform pT2) -> float"""
        return _almath.Transform_distance(self, *args)

    def toVector(self):
        """toVector(self) -> vectorFloat"""
        return _almath.Transform_toVector(self)

    def __str__(self):
        """__str__(self) -> char"""
        return _almath.Transform___str__(self)

    def __repr__(self):
        """__repr__(self) -> char"""
        return _almath.Transform___repr__(self)

    def __mul__(self, *args):
        """
        __mul__(self, Transform pT2) -> Transform
        __mul__(self, Position3D rhs) -> Position3D
        """
        return _almath.Transform___mul__(self, *args)

    __swig_destroy__ = _almath.delete_Transform
    __del__ = lambda self : None;
Transform_swigregister = _almath.Transform_swigregister
Transform_swigregister(Transform)

def Transform_fromRotX(*args):
  """Transform_fromRotX(float pRotX) -> Transform"""
  return _almath.Transform_fromRotX(*args)

def Transform_fromRotY(*args):
  """Transform_fromRotY(float pRotY) -> Transform"""
  return _almath.Transform_fromRotY(*args)

def Transform_fromRotZ(*args):
  """Transform_fromRotZ(float pRotZ) -> Transform"""
  return _almath.Transform_fromRotZ(*args)

def Transform_from3DRotation(*args):
  """Transform_from3DRotation(float pWX, float pWY, float pWZ) -> Transform"""
  return _almath.Transform_from3DRotation(*args)

def Transform_fromPosition(*args):
  """
    fromPosition(float pX, float pY, float pZ) -> Transform
    Transform_fromPosition(float pX, float pY, float pZ, float pWX, float pWY, 
        float pWZ) -> Transform
    """
  return _almath.Transform_fromPosition(*args)


def transformPreMultiply(*args):
  """transformPreMultiply(Transform pT, Transform pTOut)"""
  return _almath.transformPreMultiply(*args)

def transformFromRotX(*args):
  """transformFromRotX(float pRotX) -> Transform"""
  return _almath.transformFromRotX(*args)

def transformFromRotY(*args):
  """transformFromRotY(float pRotY) -> Transform"""
  return _almath.transformFromRotY(*args)

def transformFromRotZ(*args):
  """transformFromRotZ(float pRotZ) -> Transform"""
  return _almath.transformFromRotZ(*args)

def transformFrom3DRotation(*args):
  """transformFrom3DRotation(float pWX, float pWY, float pWZ) -> Transform"""
  return _almath.transformFrom3DRotation(*args)

def transformInvertInPlace(*args):
  """transformInvertInPlace(Transform pT)"""
  return _almath.transformInvertInPlace(*args)

def pinv(*args):
  """pinv(Transform pT) -> Transform"""
  return _almath.pinv(*args)

def transformDiff(*args):
  """transformDiff(Transform pT1, Transform pT2) -> Transform"""
  return _almath.transformDiff(*args)

def transformDistanceSquared(*args):
  """transformDistanceSquared(Transform pT1, Transform pT2) -> float"""
  return _almath.transformDistanceSquared(*args)

def transformDistance(*args):
  """transformDistance(Transform pT1, Transform pT2) -> float"""
  return _almath.transformDistance(*args)
class Velocity3D(_object):
    """Proxy of C++ AL::Math::Velocity3D class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Velocity3D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Velocity3D, name)
    __swig_setmethods__["xd"] = _almath.Velocity3D_xd_set
    __swig_getmethods__["xd"] = _almath.Velocity3D_xd_get
    if _newclass:xd = _swig_property(_almath.Velocity3D_xd_get, _almath.Velocity3D_xd_set)
    __swig_setmethods__["yd"] = _almath.Velocity3D_yd_set
    __swig_getmethods__["yd"] = _almath.Velocity3D_yd_get
    if _newclass:yd = _swig_property(_almath.Velocity3D_yd_get, _almath.Velocity3D_yd_set)
    __swig_setmethods__["zd"] = _almath.Velocity3D_zd_set
    __swig_getmethods__["zd"] = _almath.Velocity3D_zd_get
    if _newclass:zd = _swig_property(_almath.Velocity3D_zd_get, _almath.Velocity3D_zd_set)
    def __init__(self, *args): 
        """
        __init__(self) -> Velocity3D
        __init__(self, float pInit) -> Velocity3D
        __init__(self, float pXd, float pYd, float pZd) -> Velocity3D
        __init__(self, vectorFloat pFloats) -> Velocity3D
        """
        this = _almath.new_Velocity3D(*args)
        try: self.this.append(this)
        except: self.this = this
    def __add__(self, *args):
        """__add__(self, Velocity3D pVel2) -> Velocity3D"""
        return _almath.Velocity3D___add__(self, *args)

    def __sub__(self, *args):
        """__sub__(self, Velocity3D pVel2) -> Velocity3D"""
        return _almath.Velocity3D___sub__(self, *args)

    def __pos__(self):
        """__pos__(self) -> Velocity3D"""
        return _almath.Velocity3D___pos__(self)

    def __neg__(self):
        """__neg__(self) -> Velocity3D"""
        return _almath.Velocity3D___neg__(self)

    def __iadd__(self, *args):
        """__iadd__(self, Velocity3D pVel2) -> Velocity3D"""
        return _almath.Velocity3D___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(self, Velocity3D pVel2) -> Velocity3D"""
        return _almath.Velocity3D___isub__(self, *args)

    def __eq__(self, *args):
        """__eq__(self, Velocity3D pVel2) -> bool"""
        return _almath.Velocity3D___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, Velocity3D pVel2) -> bool"""
        return _almath.Velocity3D___ne__(self, *args)

    def __mul__(self, *args):
        """__mul__(self, float pVal) -> Velocity3D"""
        return _almath.Velocity3D___mul__(self, *args)

    def __div__(self, *args):
        """__div__(self, float pVal) -> Velocity3D"""
        return _almath.Velocity3D___div__(self, *args)

    def __imul__(self, *args):
        """__imul__(self, float pVal) -> Velocity3D"""
        return _almath.Velocity3D___imul__(self, *args)

    def __idiv__(self, *args):
        """__idiv__(self, float pVal) -> Velocity3D"""
        return _almath.Velocity3D___idiv__(self, *args)

    def isNear(self, *args):
        """
        isNear(self, Velocity3D pVel2, float pEpsilon = 0.0001) -> bool
        isNear(self, Velocity3D pVel2) -> bool
        """
        return _almath.Velocity3D_isNear(self, *args)

    def norm(self):
        """norm(self) -> float"""
        return _almath.Velocity3D_norm(self)

    def normalize(self):
        """normalize(self) -> Velocity3D"""
        return _almath.Velocity3D_normalize(self)

    def toVector(self):
        """toVector(self) -> vectorFloat"""
        return _almath.Velocity3D_toVector(self)

    def __repr__(self):
        """__repr__(self) -> char"""
        return _almath.Velocity3D___repr__(self)

    def __rmul__(self, *args):
        """__rmul__(self, float lhs) -> Velocity3D"""
        return _almath.Velocity3D___rmul__(self, *args)

    __swig_destroy__ = _almath.delete_Velocity3D
    __del__ = lambda self : None;
Velocity3D_swigregister = _almath.Velocity3D_swigregister
Velocity3D_swigregister(Velocity3D)

def transformToFloatVector(*args):
  """
    transformToFloatVector(Transform pT, vectorFloat pTOut)
    transformToFloatVector(Transform pT) -> vectorFloat
    """
  return _almath.transformToFloatVector(*args)

def determinant(*args):
  """
    determinant(Rotation pRot) -> float
    determinant(Transform pT) -> float
    determinant(vectorFloat pFloats) -> float
    """
  return _almath.determinant(*args)

def transformInverse(*args):
  """
    transformInverse(Transform pT, Transform pTOut)
    transformInverse(Transform pT) -> Transform
    """
  return _almath.transformInverse(*args)

def transformFromPosition(*args):
  """
    transformFromPosition(float pX, float pY, float pZ) -> Transform
    transformFromPosition(float pX, float pY, float pZ, float pWX, float pWY, 
        float pWZ) -> Transform
    """
  return _almath.transformFromPosition(*args)

class Velocity6D(_object):
    """Proxy of C++ AL::Math::Velocity6D class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Velocity6D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Velocity6D, name)
    __swig_setmethods__["xd"] = _almath.Velocity6D_xd_set
    __swig_getmethods__["xd"] = _almath.Velocity6D_xd_get
    if _newclass:xd = _swig_property(_almath.Velocity6D_xd_get, _almath.Velocity6D_xd_set)
    __swig_setmethods__["yd"] = _almath.Velocity6D_yd_set
    __swig_getmethods__["yd"] = _almath.Velocity6D_yd_get
    if _newclass:yd = _swig_property(_almath.Velocity6D_yd_get, _almath.Velocity6D_yd_set)
    __swig_setmethods__["zd"] = _almath.Velocity6D_zd_set
    __swig_getmethods__["zd"] = _almath.Velocity6D_zd_get
    if _newclass:zd = _swig_property(_almath.Velocity6D_zd_get, _almath.Velocity6D_zd_set)
    __swig_setmethods__["wxd"] = _almath.Velocity6D_wxd_set
    __swig_getmethods__["wxd"] = _almath.Velocity6D_wxd_get
    if _newclass:wxd = _swig_property(_almath.Velocity6D_wxd_get, _almath.Velocity6D_wxd_set)
    __swig_setmethods__["wyd"] = _almath.Velocity6D_wyd_set
    __swig_getmethods__["wyd"] = _almath.Velocity6D_wyd_get
    if _newclass:wyd = _swig_property(_almath.Velocity6D_wyd_get, _almath.Velocity6D_wyd_set)
    __swig_setmethods__["wzd"] = _almath.Velocity6D_wzd_set
    __swig_getmethods__["wzd"] = _almath.Velocity6D_wzd_get
    if _newclass:wzd = _swig_property(_almath.Velocity6D_wzd_get, _almath.Velocity6D_wzd_set)
    def __init__(self, *args): 
        """
        __init__(self) -> Velocity6D
        __init__(self, float pInit) -> Velocity6D
        __init__(self, float pXd, float pYd, float pZd, float pWxd, float pWyd, 
            float pWzd) -> Velocity6D
        __init__(self, vectorFloat pFloats) -> Velocity6D
        """
        this = _almath.new_Velocity6D(*args)
        try: self.this.append(this)
        except: self.this = this
    def __add__(self, *args):
        """__add__(self, Velocity6D pVel2) -> Velocity6D"""
        return _almath.Velocity6D___add__(self, *args)

    def __sub__(self, *args):
        """__sub__(self, Velocity6D pVel2) -> Velocity6D"""
        return _almath.Velocity6D___sub__(self, *args)

    def __pos__(self):
        """__pos__(self) -> Velocity6D"""
        return _almath.Velocity6D___pos__(self)

    def __neg__(self):
        """__neg__(self) -> Velocity6D"""
        return _almath.Velocity6D___neg__(self)

    def __mul__(self, *args):
        """__mul__(self, float pVal) -> Velocity6D"""
        return _almath.Velocity6D___mul__(self, *args)

    def __div__(self, *args):
        """__div__(self, float pVal) -> Velocity6D"""
        return _almath.Velocity6D___div__(self, *args)

    def __eq__(self, *args):
        """__eq__(self, Velocity6D pVel2) -> bool"""
        return _almath.Velocity6D___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, Velocity6D pVel2) -> bool"""
        return _almath.Velocity6D___ne__(self, *args)

    def __imul__(self, *args):
        """__imul__(self, float pVal) -> Velocity6D"""
        return _almath.Velocity6D___imul__(self, *args)

    def __idiv__(self, *args):
        """__idiv__(self, float pVal) -> Velocity6D"""
        return _almath.Velocity6D___idiv__(self, *args)

    def isNear(self, *args):
        """
        isNear(self, Velocity6D pVel2, float pEpsilon = 0.0001) -> bool
        isNear(self, Velocity6D pVel2) -> bool
        """
        return _almath.Velocity6D_isNear(self, *args)

    def norm(self):
        """norm(self) -> float"""
        return _almath.Velocity6D_norm(self)

    def normalize(self):
        """normalize(self) -> Velocity6D"""
        return _almath.Velocity6D_normalize(self)

    def toVector(self):
        """toVector(self) -> vectorFloat"""
        return _almath.Velocity6D_toVector(self)

    def __repr__(self):
        """__repr__(self) -> char"""
        return _almath.Velocity6D___repr__(self)

    def __rmul__(self, *args):
        """__rmul__(self, float lhs) -> Velocity6D"""
        return _almath.Velocity6D___rmul__(self, *args)

    __swig_destroy__ = _almath.delete_Velocity6D
    __del__ = lambda self : None;
Velocity6D_swigregister = _almath.Velocity6D_swigregister
Velocity6D_swigregister(Velocity6D)

class TransformAndVelocity6D(_object):
    """Proxy of C++ AL::Math::TransformAndVelocity6D class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TransformAndVelocity6D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TransformAndVelocity6D, name)
    __swig_setmethods__["T"] = _almath.TransformAndVelocity6D_T_set
    __swig_getmethods__["T"] = _almath.TransformAndVelocity6D_T_get
    if _newclass:T = _swig_property(_almath.TransformAndVelocity6D_T_get, _almath.TransformAndVelocity6D_T_set)
    __swig_setmethods__["V"] = _almath.TransformAndVelocity6D_V_set
    __swig_getmethods__["V"] = _almath.TransformAndVelocity6D_V_get
    if _newclass:V = _swig_property(_almath.TransformAndVelocity6D_V_get, _almath.TransformAndVelocity6D_V_set)
    def isNear(self, *args):
        """
        isNear(self, TransformAndVelocity6D pTV2, float pEpsilon = 0.0001) -> bool
        isNear(self, TransformAndVelocity6D pTV2) -> bool
        """
        return _almath.TransformAndVelocity6D_isNear(self, *args)

    def __repr__(self):
        """__repr__(self) -> char"""
        return _almath.TransformAndVelocity6D___repr__(self)

    def __init__(self): 
        """__init__(self) -> TransformAndVelocity6D"""
        this = _almath.new_TransformAndVelocity6D()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _almath.delete_TransformAndVelocity6D
    __del__ = lambda self : None;
TransformAndVelocity6D_swigregister = _almath.TransformAndVelocity6D_swigregister
TransformAndVelocity6D_swigregister(TransformAndVelocity6D)

def norm(*args):
  """
    norm(Position2D pPos) -> float
    norm(Position3D pPos) -> float
    norm(Position6D pPos) -> float
    norm(Quaternion pQua) -> float
    norm(Rotation3D pRot) -> float
    norm(Transform pT) -> float
    norm(Velocity3D pVel) -> float
    norm(Velocity6D pVel) -> float
    """
  return _almath.norm(*args)

def normalize(*args):
  """
    normalize(Position2D pPos) -> Position2D
    normalize(Position3D pPos) -> Position3D
    normalize(Position6D pPos) -> Position6D
    normalize(Quaternion pQua) -> Quaternion
    normalize(Velocity3D pVel) -> Velocity3D
    normalize(Velocity6D pVel) -> Velocity6D
    """
  return _almath.normalize(*args)


def getDubinsSolutions(*args):
  """getDubinsSolutions(Pose2D pTargetPose, float pCircleRadius) -> vectorPose2D"""
  return _almath.getDubinsSolutions(*args)

def avoidFootCollision(*args):
  """
    avoidFootCollision(vectorPose2D pLFootBoundingBox, vectorPose2D pRFootBoundingBox, 
        bool pIsLeftSupport, Pose2D pMove) -> bool
    """
  return _almath.avoidFootCollision(*args)

def clipFootWithEllipse(*args):
  """clipFootWithEllipse(float pMaxFootX, float pMaxFootY, Pose2D pMove) -> bool"""
  return _almath.clipFootWithEllipse(*args)

def transformLogarithmInPlace(*args):
  """transformLogarithmInPlace(Transform pT, Velocity6D pVel)"""
  return _almath.transformLogarithmInPlace(*args)

def transformLogarithm(*args):
  """transformLogarithm(Transform pT) -> Velocity6D"""
  return _almath.transformLogarithm(*args)

def velocityExponential(*args):
  """velocityExponential(Velocity6D pVel) -> Transform"""
  return _almath.velocityExponential(*args)

def velocityExponentialInPlace(*args):
  """velocityExponentialInPlace(Velocity6D pVel, Transform pT)"""
  return _almath.velocityExponentialInPlace(*args)

def changeReferenceVelocity6D(*args):
  """changeReferenceVelocity6D(Transform pT, Velocity6D pVelIn, Velocity6D pVelOut)"""
  return _almath.changeReferenceVelocity6D(*args)

def changeReferencePosition6D(*args):
  """changeReferencePosition6D(Transform pT, Position6D pPosIn, Position6D pPosOut)"""
  return _almath.changeReferencePosition6D(*args)

def changeReferencePosition3DInPlace(*args):
  """changeReferencePosition3DInPlace(Transform pT, Position3D pPosOut)"""
  return _almath.changeReferencePosition3DInPlace(*args)

def changeReferenceTransposePosition3DInPlace(*args):
  """changeReferenceTransposePosition3DInPlace(Transform pT, Position3D pPosOut)"""
  return _almath.changeReferenceTransposePosition3DInPlace(*args)

def changeReferencePosition3D(*args):
  """changeReferencePosition3D(Transform pT, Position3D pPosIn, Position3D pPosOut)"""
  return _almath.changeReferencePosition3D(*args)

def changeReferenceTransposePosition3D(*args):
  """changeReferenceTransposePosition3D(Transform pT, Position3D pPosIn, Position3D pPosOut)"""
  return _almath.changeReferenceTransposePosition3D(*args)

def changeReferenceTransform(*args):
  """changeReferenceTransform(Transform pT, Transform pTIn, Transform pTOut)"""
  return _almath.changeReferenceTransform(*args)

def changeReferenceTransposeTransform(*args):
  """changeReferenceTransposeTransform(Transform pT, Transform pTIn, Transform pTOut)"""
  return _almath.changeReferenceTransposeTransform(*args)

def changeReferenceTransposeVelocity6D(*args):
  """changeReferenceTransposeVelocity6D(Transform pT, Velocity6D pVelIn, Velocity6D pVelOut)"""
  return _almath.changeReferenceTransposeVelocity6D(*args)

def changeReferenceTransposePosition6D(*args):
  """changeReferenceTransposePosition6D(Transform pT, Position6D pPosIn, Position6D pPosOut)"""
  return _almath.changeReferenceTransposePosition6D(*args)

def transformMeanInPlace(*args):
  """transformMeanInPlace(Transform pTIn1, Transform pTIn2, float pVal, Transform pTOut)"""
  return _almath.transformMeanInPlace(*args)

def transformFromPosition3DInPlace(*args):
  """transformFromPosition3DInPlace(Position3D pPosition, Transform pTransform)"""
  return _almath.transformFromPosition3DInPlace(*args)

def transformFromPosition3D(*args):
  """transformFromPosition3D(Position3D pPosition) -> Transform"""
  return _almath.transformFromPosition3D(*args)

def transformFromRotationInPlace(*args):
  """transformFromRotationInPlace(Rotation pRotation, Transform pTransform)"""
  return _almath.transformFromRotationInPlace(*args)

def transformFromRotation(*args):
  """transformFromRotation(Rotation pRotation) -> Transform"""
  return _almath.transformFromRotation(*args)

def rotationFromTransformInPlace(*args):
  """rotationFromTransformInPlace(Transform pTransform, Rotation pRotation)"""
  return _almath.rotationFromTransformInPlace(*args)

def rotationFromTransform(*args):
  """rotationFromTransform(Transform pTransform) -> Rotation"""
  return _almath.rotationFromTransform(*args)

def rotation3DFromRotation(*args):
  """rotation3DFromRotation(Rotation pRotation) -> Rotation3D"""
  return _almath.rotation3DFromRotation(*args)

def position6DFromTransformInPlace(*args):
  """position6DFromTransformInPlace(Transform pT, Position6D pPos)"""
  return _almath.position6DFromTransformInPlace(*args)

def position6DFromTransform(*args):
  """position6DFromTransform(Transform pT) -> Position6D"""
  return _almath.position6DFromTransform(*args)

def transformFromPose2DInPlace(*args):
  """transformFromPose2DInPlace(Pose2D pPose, Transform pT)"""
  return _almath.transformFromPose2DInPlace(*args)

def transformFromPose2D(*args):
  """transformFromPose2D(Pose2D pPose) -> Transform"""
  return _almath.transformFromPose2D(*args)

def pose2DFromTransformInPlace(*args):
  """pose2DFromTransformInPlace(Transform pT, Pose2D pPos)"""
  return _almath.pose2DFromTransformInPlace(*args)

def pose2DFromTransform(*args):
  """pose2DFromTransform(Transform pT) -> Pose2D"""
  return _almath.pose2DFromTransform(*args)

def transformFromRotation3D(*args):
  """transformFromRotation3D(Rotation3D pRotation) -> Transform"""
  return _almath.transformFromRotation3D(*args)

def transformFromPosition6D(*args):
  """transformFromPosition6D(Position6D pPosition6D) -> Transform"""
  return _almath.transformFromPosition6D(*args)

def position6DFromTransformDiffInPlace(*args):
  """position6DFromTransformDiffInPlace(Transform pCurrent, Transform pTarget, Position6D result)"""
  return _almath.position6DFromTransformDiffInPlace(*args)

def position6DFromTransformDiff(*args):
  """position6DFromTransformDiff(Transform pCurrent, Transform pTarget) -> Position6D"""
  return _almath.position6DFromTransformDiff(*args)

def position3DFromTransformInPlace(*args):
  """position3DFromTransformInPlace(Transform pT, Position3D pPos)"""
  return _almath.position3DFromTransformInPlace(*args)

def position3DFromTransform(*args):
  """position3DFromTransform(Transform pT) -> Position3D"""
  return _almath.position3DFromTransform(*args)

def rotation3DFromTransform(*args):
  """rotation3DFromTransform(Transform pT) -> Rotation3D"""
  return _almath.rotation3DFromTransform(*args)

def transformFromQuaternion(*args):
  """transformFromQuaternion(Quaternion pQua) -> Transform"""
  return _almath.transformFromQuaternion(*args)

def quaternionFromTransform(*args):
  """quaternionFromTransform(Transform pT) -> Quaternion"""
  return _almath.quaternionFromTransform(*args)

def clipData(*args):
  """clipData(float pMin, float pMax, float pData) -> bool"""
  return _almath.clipData(*args)

def position6DFromVelocity6D(*args):
  """position6DFromVelocity6D(Velocity6D pVel) -> Position6D"""
  return _almath.position6DFromVelocity6D(*args)

_4_PI_ = cvar._4_PI_
_2_PI_ = cvar._2_PI_
PI = cvar.PI
PI_2 = cvar.PI_2
PI_4 = cvar.PI_4
TO_RAD = cvar.TO_RAD
TO_DEG = cvar.TO_DEG

def transformMean(*args):
  """
    transformMean(Transform pTIn1, Transform pTIn2, float pVal = 0.5) -> Transform
    transformMean(Transform pTIn1, Transform pTIn2) -> Transform
    """
  return _almath.transformMean(*args)

def transformFromRotationPosition3D(*args):
  """
    transformFromRotationPosition3D(Rotation pRot, float pX, float pY, float pZ) -> Transform
    transformFromRotationPosition3D(Rotation pRot, Position3D pPos) -> Transform
    """
  return _almath.transformFromRotationPosition3D(*args)

def transformFromRotVecInPlace(*args):
  """
    transformFromRotVecInPlace(int pAxis, float pTheta, Position3D pPos, Transform pT)
    transformFromRotVecInPlace(Position3D pPos, Transform pT)
    """
  return _almath.transformFromRotVecInPlace(*args)

def transformFromRotVec(*args):
  """
    transformFromRotVec(int pAxis, float pTheta, Position3D pPos) -> Transform
    transformFromRotVec(Position3D pPos) -> Transform
    transformFromRotVec(int pAxis, float pTheta) -> Transform
    """
  return _almath.transformFromRotVec(*args)

def axisRotationProjection(*args):
  """
    axisRotationProjection(Position3D pPos, Transform pT) -> Transform
    axisRotationProjection(Position3D pAxis, Rotation pRot) -> Rotation
    """
  return _almath.axisRotationProjection(*args)

def axisRotationProjectionInPlace(*args):
  """
    axisRotationProjectionInPlace(Position3D pPos, Transform pT)
    axisRotationProjectionInPlace(Position3D pPos, Rotation pRot)
    """
  return _almath.axisRotationProjectionInPlace(*args)

def orthogonalSpace(*args):
  """
    orthogonalSpace(Position3D pPos, Transform pTOut)
    orthogonalSpace(Position3D pPos) -> Transform
    """
  return _almath.orthogonalSpace(*args)

def __mul__(*args):
  """
    __mul__(float pM, Position2D pPos1) -> Position2D
    __mul__(float pM, Position3D pPos1) -> Position3D
    __mul__(float pM, Velocity3D pVel1) -> Velocity3D
    __mul__(float pVal, Velocity6D pVel) -> Velocity6D
    __mul__(Transform pT, Position3D pPos) -> Position3D
    __mul__(Rotation pRot, Position3D pPos) -> Position3D
    __mul__(float pVal, Position6D pPos) -> Velocity6D
    """
  return _almath.__mul__(*args)

def rotationFromAngleDirection(*args):
  """
    rotationFromAngleDirection(float pAngle, float pX, float pY, float pZ) -> Rotation
    rotationFromAngleDirection(float pTheta, Position3D pPos) -> Rotation
    """
  return _almath.rotationFromAngleDirection(*args)

