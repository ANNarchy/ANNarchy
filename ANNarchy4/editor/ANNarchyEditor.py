import sys
import os

from PyQt4.QtGui import QApplication, QMainWindow, QMessageBox
from PyQt4 import QtCore

# generated by pyuic4
from ui_ANNarchyEditor import Ui_ANNarchyEditor 

# buisness logic
from CodeView import CodeView
from ListView import ListView 

from GLNetwork import GLNetworkWidget
from GLPlotWidget import GLPlot1d

import ANNarchy4

import code
            
class GeneralWidget(object):
    signal_change_grid = QtCore.pyqtSignal(int, int)
    
    def __init__(self, widget, main_window):
        self._widget = widget
        self._main_window = main_window
        
        #
        # initialize the several tab pages
        self._setup_obj()
        self._setup_net()
        self._setup_vis()

    def _setup_obj(self):
        self._neurons = ListView(self._widget.neur_general, 
                                 self._main_window, 
                                 "neuron type"
                                 )
        self._neurons.initialize()
        
        self._synapses = ListView(self._widget.syn_general, 
                                  self._main_window, 
                                  "synapse type"
                                  )
        self._synapses.initialize()

    def _setup_net(self):
        self._params = ListView(self._widget.par_general, 
                                self._main_window, 
                                "params"
                                )
        self._params.initialize()

    def _setup_vis(self):
        self._widget.change_grid.pressed[()].connect(self.change_grid)
        self.change_grid() # initialize with default values
        
    def change_grid(self):
        """
        check the edit lines and modify width and height of the visualized grid.
        """
        try:
            x_size = int(self._widget.grid_x_dim.text())
            y_size = int(self._widget.grid_y_dim.text())
        except ValueError:
            x_size = 1
            y_size = 1

        self._main_window.signal_change_grid_from_general.emit(x_size, y_size)
        
class EditorMainWindow(QMainWindow):
    signal_change_grid_from_general = QtCore.pyqtSignal(int, int)
    signal_net_editor_to_pop_view = QtCore.pyqtSignal(int, int)
    
    def __init__(self, func, vis):
        ANNarchy4.Global._visualizer = self
        
        super(QMainWindow, self).__init__()
        
        self._ui = Ui_ANNarchyEditor()
        self._ui.setupUi(self)
        
        self._func = func
        self._vis = vis
        
        self._tab_index = 0
        
        self._w = self.width()
        self._h = self.height()
        self.setWindowTitle('ANNarchy4.1 ultimate editor')
        
        #
        # editor instances
        self._obj_editor = CodeView(self._ui.objects, int( self._w * 0.80), int ( self._h * 0.90))
        self._env_editor = CodeView(self._ui.environment, int( self._w * 0.80), int ( self._h * 0.90))
        self._comp_editor = CodeView(self._ui.complete, int( self._w * 0.80), int ( self._h * 0.90))
        
        self._net_editor = GLNetworkWidget(self._ui.editor, self) 
        
        # 
        # stack widget for general properties.
        self._general = GeneralWidget(self._ui, self)
        self._connect_signals()

    def _connect_signals(self):
        #
        # if the user changes the view the corresponding properties will be selected
        self._ui.views.connect(self._ui.views, QtCore.SIGNAL("currentChanged(int)"), self._ui.general, QtCore.SLOT("setCurrentIndex(int)"))
        self._ui.views.connect(self._ui.views, QtCore.SIGNAL("currentChanged(int)"), self._ui.special, QtCore.SLOT("setCurrentIndex(int)"))
        self._ui.views.connect(self._ui.views, QtCore.SIGNAL("currentChanged(int)"), self, QtCore.SLOT("_set_current_tab(int)"))
        
        self._ui.actionOpen.triggered[()].connect(self.load_file)
        
        #
        # signals from general
        self.signal_change_grid_from_general.connect(self.change_grid)
        
        self.signal_net_editor_to_pop_view.connect(self.test)
        
    @QtCore.pyqtSlot(int, int)
    def test(self, tab, pop):
        self._ui.stackedWidget_2.setCurrentIndex(tab)
        
        if tab != 0:
            print 'Update population', pop 
            obj = ANNarchy4.get_population('Population'+str(pop))
            if obj != None:
                self._ui.pop_name.setText(obj.name)
                self._ui.pop_size.setText(str(obj.geometry))
        
    @QtCore.pyqtSlot(int, int)
    def change_grid(self, x_size, y_size):
        self._x_size = x_size
        self._y_size = y_size
        
        #
        # delete old ones
        while self._ui.grid_root.count():
            item = self._ui.grid_root.takeAt(0)
            widget = item.widget()
            widget.deleteLater()        

        self._gl_instances = {}
        #
        # create new widgets
        if self._x_size > 1 or self._y_size > 1:
            for y in xrange(self._y_size):
                for x in xrange(self._x_size):
                    tmp = GLPlot1d(self._ui.visualizer)
                    self._gl_instances.update( { y * self._x_size + x : tmp})
                    self._ui.grid_root.addWidget(tmp, x, y)
        else:
            tmp = GLPlot1d(self._ui.visualizer)
            self._gl_instances.update( { 0 : tmp})
            self._ui.grid_root.addWidget( tmp, 0, 0)

    def set_color(self, x_pos, y_pos, r, g, b):
        #try:
        self._gl_instances[y_pos * self._x_size + x_pos].set_color(r, g, b)
        #except AttributeError:
        #    print 'No plot with coord', (x_pos, y_pos),'in grid',(self._x_size,self._y_size)
        
    def set_data(self, x_pos, y_pos, x, y):
        #try:
        self._gl_instances[y_pos * self._x_size + x_pos].set_data(x,y)
        #except AttributeError:
        #    print 'No plot with coord', (x_pos, y_pos),'in grid',(self._x_size,self._y_size)

    def render(self):
        for i in xrange(self._ui.grid_root.count()):
            self._ui.grid_root.itemAt(i).widget()._render.emit()
        
                
    def resizeEvent(self, *args, **kwargs):
        self._w = self.width()
        self._h = self.height()
        
        self._ui.splitter.setMinimumSize( int (self._w * 0.80), int ( self._h * 0.90) )
        self._ui.splitter.setMaximumSize( int (self._w * 0.80)+1, int ( self._h * 0.90)+1 )

        self._ui.visualizer.setMinimumSize( int (self._w * 0.80), int ( self._h * 0.90) )
        self._ui.visualizer.setMaximumSize( int (self._w * 0.80)+1, int ( self._h * 0.90)+1 )
        
        self._net_editor.setMinimumSize( int (self._w * 0.80), int ( self._h * 0.90) ) #TODO:
        self._net_editor.setMaximumSize( int (self._w * 0.80)+1, int ( self._h * 0.90)+1 ) # we need to set min and max, else the GL window does not react
        
        self._comp_editor.setMinimumSize( int (self._w * 0.80), int ( self._h * 0.90) ) #TODO:        
        self._env_editor.setMinimumSize( int (self._w * 0.80), int ( self._h * 0.90) ) #TODO:
        self._obj_editor.setMinimumSize( int (self._w * 0.80), int ( self._h * 0.90) ) #TODO:
                
        return QMainWindow.resizeEvent(self, *args, **kwargs)
    
    def compile(self):

        ANNarchy4.compile()
        
        self._func()
        
    @QtCore.pyqtSlot()
    def load_file(self):
        if self._tab_index == 5:
            self._comp_editor.load_file()
        else:
            QMessageBox.warning(self,"Open file", "Opening a file is only possible in the complete script view.")
            self._ui.views.setCurrentIndex(5)

    @QtCore.pyqtSlot(int)
    def _set_current_tab(self, idx):
        self._tab_index = idx
        
class ANNarchyEditor(object):
    
    def __init__(self, func, vis):
        app = QApplication(sys.argv)
         
        w = EditorMainWindow(func, vis)
        
        w.show()
         
        sys.exit(app.exec_())
        
        